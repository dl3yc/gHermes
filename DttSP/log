Only in .: AUTHORS
diff ./bufvec.c /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/bufvec.c
40c40
< //#include <malloc16.h>
---
> #include <malloc16.h>
46a47,66
> safealloc16(int count, int nbytes, char *tag)
> {	
> 	char *p = (char *)_aligned_malloc(count*nbytes, 16);
> 	memset(p,0,count*nbytes);
> 
> 	if (!p)
> 	{
> 		if (tag && *tag)
> 			fprintf(stderr, "safealloc: %s\n", tag);
> 		else
> 			perror("safealloc");
> 		exit(1);
> 	}
> 
> 	_safemem_currcount += count * nbytes;
> 
> 	return p;
> }
> 
> char *
91a112,117
> REAL *
> newvec_REAL_16(int size, char *tag)
> {
> 	return (REAL *) safealloc(size, sizeof(REAL), tag);
> }
> 
123c149
< newvec_COMPLEX_fftw(int size, char *tag)
---
> newvec_COMPLEX_16(int size, char *tag)
125c151
< 	COMPLEX *p = fftwf_malloc(size*sizeof(COMPLEX));
---
> 	COMPLEX *p = (COMPLEX *)safealloc16(size, sizeof(COMPLEX), tag);
139c165
< delvec_COMPLEX_fftw(COMPLEX *vec)
---
> delvec_COMPLEX_16(COMPLEX *vec)
141c167,168
< 	fftwf_free((char *) vec);
---
> 	//fftwf_free((char *) vec);
> 	_aligned_free((char *)vec);
diff ./bufvec.h /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/bufvec.h
82a83
> extern REAL *newvec_REAL_16(int size, char *tag);
88,89c89,90
< extern COMPLEX *newvec_COMPLEX_fftw(int size, char *tag);
< extern void delvec_COMPLEX_fftw(COMPLEX * buf);
---
> extern COMPLEX *newvec_COMPLEX_16(int size, char *tag);
> extern void delvec_COMPLEX_16(COMPLEX * buf);
Only in .: ChangeLog
diff ./common.h /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/common.h
72c72
< //#include <windows.h>
---
> #include <windows.h>
76,77c76,77
< //#include <malloc16.h>
< //typedef long uid_t;
---
> #include <malloc.h>
> typedef long uid_t;
diff ./correctIQ.c /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/correctIQ.c
1,63c1,115
< /* correctIQ.c
< 
< This routine restores quadrature between arms of an analytic signal
< possibly distorted by ADC hardware.
< 
< This file is part of a program that implements a Software-Defined Radio.
< 
< Copyright (C) 2004, 2005, 2006 by Frank Brickle, AB2KT and Bob McGwier, N4HY
< 
< This program is free software; you can redistribute it and/or modify
< it under the terms of the GNU General Public License as published by
< the Free Software Foundation; either version 2 of the License, or
< (at your option) any later version.
< 
< This program is distributed in the hope that it will be useful,
< but WITHOUT ANY WARRANTY; without even the implied warranty of
< MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
< GNU General Public License for more details.
< 
< You should have received a copy of the GNU General Public License
< along with this program; if not, write to the Free Software
< Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
< 
< The authors can be reached by email at
< 
< ab2kt@arrl.net
< or
< rwmcgwier@comcast.net
< 
< or by paper mail at
< 
< The DTTS Microwave Society
< 6 Kathleen Place
< Bridgewater, NJ 08807
< */
< 
< #include <common.h>
< 
< IQ
< newCorrectIQ (REAL phase, REAL gain)
< {
< 	IQ iq = (IQ) safealloc (1, sizeof (iqstate), "IQ state");
< 	iq->phase = phase;
< 	iq->gain = gain;
< 	return iq;
< }
< 
< void
< delCorrectIQ (IQ iq)
< {
< 	safefree ((char *) iq);
< }
< 
< void
< correctIQ (CXB sigbuf, IQ iq)
< {
< 	int i;
< 	for (i = 0; i < CXBhave (sigbuf); i++)
< 	{
< 		CXBimag (sigbuf, i) += iq->phase * CXBreal (sigbuf, i);
< 		CXBreal (sigbuf, i) *= iq->gain;
< 	}
< }
---
> /* correctIQ.c
> 
> This routine restores quadrature between arms of an analytic signal
> possibly distorted by ADC hardware.
> 
> This file is part of a program that implements a Software-Defined Radio.
> 
> Copyright (C) 2004, 2005, 2006 by Frank Brickle, AB2KT and Bob McGwier, N4HY
> 
> This program is free software; you can redistribute it and/or modify
> it under the terms of the GNU General Public License as published by
> the Free Software Foundation; either version 2 of the License, or
> (at your option) any later version.
> 
> This program is distributed in the hope that it will be useful,
> but WITHOUT ANY WARRANTY; without even the implied warranty of
> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> GNU General Public License for more details.
> 
> You should have received a copy of the GNU General Public License
> along with this program; if not, write to the Free Software
> Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
> 
> The authors can be reached by email at
> 
> ab2kt@arrl.net
> or
> rwmcgwier@comcast.net
> 
> or by paper mail at
> 
> The DTTS Microwave Society
> 6 Kathleen Place
> Bridgewater, NJ 08807
> */
> 
> #include <common.h>
> 
> 
> 
> IQ
> newCorrectIQ (REAL phase, REAL gain, REAL mu)
> {
> 	IQ iq = (IQ) safealloc (1, sizeof (iqstate), "IQ state");
> 	iq->phase = phase;
> 	iq->gain = gain;
> 	iq->mu = mu;
> 	iq->leakage = 0.000000f;
> 	iq->MASK=15;
> 	iq->index=0;
> 	iq->w = (COMPLEX *)safealloc(16,sizeof(COMPLEX),"correctIQ w");
> 	iq->y = (COMPLEX *)safealloc(16,sizeof(COMPLEX),"correctIQ y");
> 	iq->del = (COMPLEX *)safealloc(16,sizeof(COMPLEX),"correctIQ del");
> 	memset((void *)iq->w,0,16*sizeof(COMPLEX));
> 	iq->wbir_tuned = TRUE;
> 	iq->wbir_state = FastAdapt;
> 	return iq;
> }
> 
> void
> delCorrectIQ (IQ iq)
> {
> 	safefree((char *)iq->w);
> 	safefree((char *)iq->y);
> 	safefree((char *)iq->del);
> 	safefree ((char *) iq);
> }
> 
> int IQdoit = 1;
> 
> void
> correctIQ (CXB sigbuf, IQ iq, BOOLEAN isTX, int subchan)
> {
> 	int i;
> 	REAL doit;
> 	if (IQdoit == 0) return;
> 	if (subchan == 0) doit = iq->mu;
> 	else doit = 0;
> 	if(!isTX)
> 	{
> 
> 		// if (subchan == 0) // removed so that sub rx's will get IQ correction
> 		switch (iq->wbir_state) {
> 			case FastAdapt:
> 				break;
> 			case SlowAdapt:
> 				break;
> 			case NoAdapt:
> 				break;
> 			default:
> 				break;
> 		}
> 
> 		for (i = 0; i < CXBhave (sigbuf); i++)
> 		{
> 			iq->del[iq->index] = CXBdata(sigbuf, i);
> 			iq->y[iq->index] = Cadd(iq->del[iq->index], Cmul(iq->w[0], Conjg(iq->del[iq->index])));
> 			iq->y[iq->index] = Cadd(iq->y[iq->index], Cmul(iq->w[1], Conjg(iq->y[iq->index])));
> 			iq->w[1] = Csub(iq->w[1], Cscl(Cmul(iq->y[iq->index], iq->y[iq->index]), doit));  // this is where the adaption happens
> 
> 			CXBdata(sigbuf, i) = iq->y[iq->index];
> 			iq->index = (iq->index + iq->MASK) & iq->MASK;
> 		}
> 		//fprintf(stderr, "w1 real: %g, w1 imag: %g\n", iq->w[1].re, iq->w[1].im); fflush(stderr); 
> 	}
> 	else
> 	{
> 		for (i = 0; i < CXBhave (sigbuf); i++)
> 		{
> 			CXBimag (sigbuf, i) += iq->phase * CXBreal (sigbuf, i);
> 			CXBreal (sigbuf, i) *= iq->gain;
> 		}
> 	}
> 
> }
diff ./correctIQ.h /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/correctIQ.h
1,15c1,31
< #ifndef _correctIQ_h
< #define _correctIQ_h
< 
< #include <bufvec.h>
< 
< typedef struct _iqstate
< {
<   REAL phase, gain;
< } *IQ, iqstate;
< 
< extern IQ newCorrectIQ (REAL phase, REAL gain);
< extern void delCorrectIQ (IQ iq);
< extern void correctIQ (CXB sigbuf, IQ iq);
< 
< #endif
---
> #ifndef _correctIQ_h
> #define _correctIQ_h
> 
> #include <bufvec.h>
> 
> typedef enum _wbir_state
> {
> 	FastAdapt,
>     SlowAdapt,
>     NoAdapt,
> 	JustSayNo
> } WBIR_STATE;
> 
> typedef struct _iqstate
> {
>   REAL phase, gain,mu, leakage;
>   COMPLEX *w;
>   COMPLEX *del;
>   COMPLEX *y;
>   COMPLEX dc;
>   int MASK;
>   int index;
>   WBIR_STATE wbir_state;
>   BOOLEAN wbir_tuned;
> } *IQ, iqstate;
> 
> extern IQ newCorrectIQ (REAL phase, REAL gain, REAL mu);
> extern void delCorrectIQ (IQ iq);
> extern void correctIQ (CXB sigbuf, IQ iq, BOOLEAN isTX, int subchan);
> #define IQFIRlength 1
> #endif
diff ./cwtones.c /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/cwtones.c
35a36,56
> void
> CWComplexOSC (OSC p, double harmonic, double phase, double amplitude)
> {
> 	int i;
> 
> 	if(OSCphase (p) > TWOPI)
> 		OSCphase (p) -= TWOPI;
> 	else if (OSCphase (p) < -TWOPI)
> 		OSCphase (p) += TWOPI;
> 	  
> 	for (i = 0; i < OSCsize (p); i++)
> 	{
> 		double harm_phase;
> 
> 		harm_phase = harmonic*OSCphase(p);
> 		CXBdata((CXB)OSCbase(p), i) = Cmplx ((REAL) (cos (OSCphase (p)) + amplitude*cos(harm_phase+phase)) ,
> 											 (IMAG) (sin (OSCphase (p)) + amplitude*sin(harm_phase+phase)));
> 		OSCphase (p) += OSCfreq (p);
>   }
> }
> 
47c68
< 	ComplexOSC (cwt->osc.gen);
---
> 	CWComplexOSC (cwt->osc.gen, cwt->harmonic, cwt->phase, cwt->amplitude);
diff ./cwtones.h /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/cwtones.h
59a60
>   double harmonic, amplitude, phase;
diff ./cxops.c /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/cxops.c
43c43
< #ifdef DONT_INCLUDE
---
> 
62d61
< #endif
diff ./datatypes.h /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/datatypes.h
41c41
< typedef unsigned int BOOLEAN;
---
> //typedef unsigned int BOOLEAN;
45d44
< typedef int HANDLE;
53d51
< 
55,56c53
< //#define INLINE __forceinline
< #define INLINE
---
> #define INLINE __forceinline
diff ./dcblock.c /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/dcblock.c
88c88,95
< 
---
> 		case DCB_SINGLE_POLE:
> 			for (i = 0; i < CXBsize (dcb->buf); i++)
> 			{
> 				COMPLEX x=CXBdata(dcb->buf,i);
> 				dcb->sigval = Cadd(Cscl(x,.00005f), Cscl(dcb->sigval,0.99995f));
> 				CXBdata (dcb->buf, i) = Csub(x,dcb->sigval);
> 			}
> 			break;
108a116
> 	dcb->sigval = cxzero;
diff ./dcblock.h /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/dcblock.h
49a50
> #define DCB_SINGLE_POLE (4)
57a59
>   COMPLEX sigval;
58a61,62
>   REAL gain;
>   BOOLEAN flag;
diff ./defs.h /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/defs.h
1,67c1,67
< /* defs.h */
< /*
< This file is part of a program that implements a Software-Defined Radio.
< 
< Copyright (C) 2004, 2005, 2006 by Frank Brickle, AB2KT and Bob McGwier, N4HY
< 
< This program is free software; you can redistribute it and/or modify
< it under the terms of the GNU General Public License as published by
< the Free Software Foundation; either version 2 of the License, or
< (at your option) any later version.
< 
< This program is distributed in the hope that it will be useful,
< but WITHOUT ANY WARRANTY; without even the implied warranty of
< MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
< GNU General Public License for more details.
< 
< You should have received a copy of the GNU General Public License
< along with this program; if not, write to the Free Software
< Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
< 
< The authors can be reached by email at
< 
< ab2kt@arrl.net
< or
< rwmcgwier@comcast.net
< 
< or by paper mail at
< 
< The DTTS Microwave Society
< 6 Kathleen Place
< Bridgewater, NJ 08807
< */
< 
< #ifndef _defs_h
< #define _defs_h
< 
< #define RINGMULT (4)
< #define METERMULT (20)
< #define SPECMULT (4)
< #define DEFRATE (48000.0)
< #define DEFSIZE (1024)
< #define DEFMODE (USB)
< #define DEFSPEC (4096)
< #define DEFCOMP (512)
< 
< #define MAXRX (2)
< 
< #ifndef MAXPATHLEN
< #define MAXPATHLEN (2048)
< #endif
< 
< typedef enum _sdrmode
< {
<   LSB,				//  0
<   USB,				//  1
<   DSB,				//  2
<   CWL,				//  3
<   CWU,				//  4
<   FMN,				//  5
<   AM,				//  6
<   DIGU,				//  7
<   SPEC,				//  8
<   DIGL,				//  9
<   SAM,				// 10
<   DRM				// 11
< } SDRMODE;
< 
---
> /* defs.h */
> /*
> This file is part of a program that implements a Software-Defined Radio.
> 
> Copyright (C) 2004, 2005, 2006 by Frank Brickle, AB2KT and Bob McGwier, N4HY
> 
> This program is free software; you can redistribute it and/or modify
> it under the terms of the GNU General Public License as published by
> the Free Software Foundation; either version 2 of the License, or
> (at your option) any later version.
> 
> This program is distributed in the hope that it will be useful,
> but WITHOUT ANY WARRANTY; without even the implied warranty of
> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> GNU General Public License for more details.
> 
> You should have received a copy of the GNU General Public License
> along with this program; if not, write to the Free Software
> Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
> 
> The authors can be reached by email at
> 
> ab2kt@arrl.net
> or
> rwmcgwier@comcast.net
> 
> or by paper mail at
> 
> The DTTS Microwave Society
> 6 Kathleen Place
> Bridgewater, NJ 08807
> */
> 
> #ifndef _defs_h
> #define _defs_h
> 
> #define RINGMULT (4)
> #define METERMULT (20)
> #define SPECMULT (4)
> #define DEFRATE (48000.0)
> #define DEFSIZE (4096)
> #define DEFMODE (USB)
> #define DEFSPEC (4096)
> #define DEFCOMP (512)
> 
> #define MAXRX (2)
> 
> #ifndef MAXPATHLEN
> #define MAXPATHLEN (2048)
> #endif
> 
> typedef enum _sdrmode
> {
>   LSB,				//  0
>   USB,				//  1
>   DSB,				//  2
>   CWL,				//  3
>   CWU,				//  4
>   FMN,				//  5
>   AM,				//  6
>   DIGU,				//  7
>   SPEC,				//  8
>   DIGL,				//  9
>   SAM,				// 10
>   DRM				// 11
> } SDRMODE;
> 
73,77c73,77
< 
< typedef enum _trxmode
< { RX, TX } TRXMODE;
< 
< #endif
---
> 
> typedef enum _trxmode
> { RX, TX } TRXMODE;
> 
> #endif
Only in .: .deps
diff ./dttspagc.c /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/dttspagc.c
1,93c1,135
< /*  dttspagc.c
< 
< This file is part of a program that implements a Software-Defined Radio.
< 
< Copyright (C) 2004, 2005, 2006 by Frank Brickle, AB2KT and Bob McGwier, N4HY
< 
< This program is free software; you can redistribute it and/or modify
< it under the terms of the GNU General Public License as published by
< the Free Software Foundation; either version 2 of the License, or
< (at your option) any later version.
< 
< This program is distributed in the hope that it will be useful,
< but WITHOUT ANY WARRANTY; without even the implied warranty of
< MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
< GNU General Public License for more details.
< 
< You should have received a copy of the GNU General Public License
< along with this program; if not, write to the Free Software
< Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
< 
< The authors can be reached by email at
< 
< ab2kt@arrl.net
< or
< rwmcgwier@comcast.net
< 
< or by paper mail at
< 
< The DTTS Microwave Society
< 6 Kathleen Place
< Bridgewater, NJ 08807
< */
< 
< 
< #include <common.h>
< 
< 
< DTTSPAGC
< newDttSPAgc (AGCMODE mode,
< 			 COMPLEX * Vec,
< 			 int BufSize,
< 			 REAL Limit,
< 			 REAL attack,
< 			 REAL decay,
< 			 REAL slope,
< 			 REAL hangtime,
< 			 REAL samprate,
< 			 REAL MaxGain, REAL MinGain, REAL CurGain, char *tag)
< {
< 	DTTSPAGC a;
< 
< 	a = (DTTSPAGC) safealloc (1, sizeof (dttspagc), tag);
< 	a->mode = mode;
< 
< 	a->attack = (REAL) (1.0 - exp (-1000.0 / (attack * samprate)));
< 	a->one_m_attack = (REAL) exp (-1000.0 / (attack * samprate));
< 
< 	a->decay = (REAL) (1.0 - exp (-1000.0 / (decay * samprate)));
< 	a->one_m_decay = (REAL) exp (-1000.0 / (decay * samprate));
< 
< 	a->fastattack = (REAL) (1.0 - exp (-1000.0 / (0.2 * samprate)));
< 	a->one_m_fastattack = (REAL) exp (-1000.0 / (0.2 * samprate));
< 
< 	a->fastdecay = (REAL) (1.0 - exp (-1000.0 / (3.0 * samprate)));
< 	a->one_m_fastdecay = (REAL) exp (-1000.0 / (3.0 * samprate));
< 
< 	strcpy (a->tag, tag);
< 	a->mask = 2 * BufSize;
< 
< 	a->hangindex = a->indx = 0;
< 	a->hangtime = hangtime * 0.001f;
< 	a->hangthresh = 0.0;
< 	a->sndx = (int) (samprate * attack * 0.003f);
< 	a->fastindx = (int)(0.002f*samprate);
< 	a->gain.fix = 10.0;
< 
< 	a->slope = slope;
< 	a->gain.top = MaxGain;
< 	a->hangthresh = a->gain.bottom = MinGain;
< 	a->gain.fastnow = a->gain.old = a->gain.now = CurGain;
< 
< 	a->gain.limit = Limit;
< 
< 	a->buff = newCXB (BufSize, Vec, "agc in buffer");
< 	a->circ = newvec_COMPLEX (a->mask, "circular agc buffer");
< 	a->mask -= 1;
< 
< 	a->fasthang = 0;
< 	a->fasthangtime = 0.1f*a->hangtime;
< 
< 	return a;
< }
< 
---
> /*  dttspagc.c
> 
> This file is part of a program that implements a Software-Defined Radio.
> 
> Copyright (C) 2004, 2005, 2006 by Frank Brickle, AB2KT and Bob McGwier, N4HY
> 
> This program is free software; you can redistribute it and/or modify
> it under the terms of the GNU General Public License as published by
> the Free Software Foundation; either version 2 of the License, or
> (at your option) any later version.
> 
> This program is distributed in the hope that it will be useful,
> but WITHOUT ANY WARRANTY; without even the implied warranty of
> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> GNU General Public License for more details.
> 
> You should have received a copy of the GNU General Public License
> along with this program; if not, write to the Free Software
> Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
> 
> The authors can be reached by email at
> 
> ab2kt@arrl.net
> or
> rwmcgwier@comcast.net
> 
> or by paper mail at
> 
> The DTTS Microwave Society
> 6 Kathleen Place
> Bridgewater, NJ 08807
> */
> 
> 
> #include <common.h>
> 
> 
> DTTSPAGC
> newDttSPAgc (AGCMODE mode,
> 			 COMPLEX *Vec,
> 			 int BufSize,   // Size of the input buffer
> 			 REAL target,   // The target voltage
> 			 REAL attack,   // Attack time constant in msec
> 			 REAL decay,    // Decay time constant in msec
> 			 REAL slope,    // Rate of change of gain after agc threshold is exceeded
> 			 REAL hangtime, // Hang Time in msec where NO decay is allowed in the agc
> 			 REAL samprate, // Sample Rate so time can be turned into sample number
> 			 REAL MaxGain,  // Maximum allowable gain
> 			 REAL MinGain,  // Minimum gain (can be -dB / less than 1.0 as in ALC or strong signals on receive
> 			 REAL CurGain,  // The initial gain setting
> 			 char *tag)     // String to emit when error conditions occur
> {
> 	DTTSPAGC a;
> 
> 	a = (DTTSPAGC) safealloc (1, sizeof (dttspagc), tag);
> 	a->mode = mode;
> 
> 	// Attack: decrease gain when input signal will produce an output signal above the target voltage
> 	// Decay:  increase gain when input signal will produce an output signal below the target voltage
> 	
> 	// Compute exponential attack rate per sample from attack time and sampler rate.
> 	a->attack = (REAL) (1.0 - exp (-1000.0 / (attack * samprate))); 
> 	// Compute 1.0 - attack time.
> 	a->one_m_attack = (REAL) (1.0 - a->attack);
> 
> 	// Compute exponential decay rate per sample from attack time and sampler rate.
> 	a->decay = (REAL) (1.0 - exp (-1000.0 / (decay * samprate)));
> 	// Compute 1.0 - decay time.
> 	a->one_m_decay = (REAL) (1.0 - a->decay);
> 
> 	// Our system has a two track agc response.  The normal one found in most receive
> 	// systems is the determined from the calculations we just made.
> 	// Ours has a fast track agc which is designed to prevent large pulse signals from pushing
> 	// us into serious attack and wait for a long decay when the signal is short duration < 3 time constants for attack
> 
> 	// Compute exponential fast attack rate per sample from fast attack time and sampler rate.
> 	a->fastattack = (REAL) (1.0 - exp (-1000.0 / (0.2 * samprate)));
> 	// Compute 1.0 - fast attack time.
> 	a->one_m_fastattack = (REAL) (1.0 - a->fastattack);
> 
> 	// Compute exponential fast decay rate per sample from fast attack time and sampler rate.
> 	a->fastdecay = (REAL) (1.0 - exp (-1000.0 / (3.0 * samprate)));
> 	// Compute 1.0 - fast decay time.
> 	a->one_m_fastdecay = (REAL) (1.0 - a->fastdecay);
> 
> 	// Save the error identification message
> 	strcpy (a->tag, tag);
> 
> 	// This computes the index max for our circular buffer
> 	a->mask = 2 * BufSize - 1;
> 	
> 	// Hangtime:  This is a period of NO allowed decay even though we need to increase gain to stay at target level
> 	// hangindex is used to compute how deep into the hang interval we are.
> 	a->hangindex = a->slowindx = 0;
> 	// Change hang time to hang length in samples using time and sample rate.
> 	a->hangtime = hangtime * 0.001f;
> 	//a->hangthresh = 0.0; // not neccessary?
> 	// We BEGIN applying decreasing gain 3 time constants ahead of the signals arrival to narrow the modulation
> 	// spread arising from modulating the signal with the agc gain.  The index to application of computed gain
> 	// sndx and it is computed as number of samples in 3 attack time constants
> 	a->out_indx = (int) (samprate * attack * 0.003f);
> 
> 	// We do the same anticipation in the fast channel but we only do two time constants.
> 	a->fastindx = (int)(0.0027f*samprate);
> 	a->gain.fix = 10.0;
> 
> 	// Slope:  The rate at which gain is decreased as signal strength increases after it exceeds the agc threshold
> 	// that is, after the required gain to reach the desired output level is LESS THAN the maximum allowable gain.
> 	a->slope = slope;
> 
> 	// gain.top = Maxgain which is the maximum allowable gain.  This determines the agc threshold
> 	a->gain.top = MaxGain;
> 	// gain.bottom = MinGain is the minimum allowable gain.  If < 0dB or 1.0, then this is an attenuation.
> 	a->hangthresh = a->gain.bottom = MinGain;
> 	// Initialize the gain state to an initial value
> 	a->gain.fastnow = a->gain.old = a->gain.now = CurGain;
> 
> 	// Set the target voltage.
> 	a->gain.target = target;
> 
> 	// Given the vector of input samples,  make a local complex buffer (struct to handle metadata associated with
> 	// the vector or array of samples
> 	a->buff = newCXB (BufSize, Vec, "agc in buffer");
> 	// Use a circular buffer for efficiency in dealing with the anticipatory part of the agc algorithm
> 	a->circ = newvec_COMPLEX (2 * BufSize, "circular agc buffer");
> 
> 	// intialize fast hang index to 0
> 	a->fasthang = 0;
> 
> 	// Whatever the hangtime is for the slow channel, make the fast agc channel hangtime 10% of it
> 	a->fasthangtime = 0.1f*a->hangtime;
> 
> 	return a;
> }
> 
99,194c141,251
< 
< void
< DttSPAgc (DTTSPAGC a, int tick)
< {
< 	int i;
< 	int hangtime = (int) (uni[0].samplerate * a->hangtime);
< 	int fasthangtime = (int) (uni[0].samplerate * a->fasthangtime);
< 
< 	REAL hangthresh;
< 
< 	if (a->hangthresh > 0)
< 		hangthresh =
< 			a->gain.top * a->hangthresh + a->gain.bottom * (REAL) (1.0 -
< 			a->hangthresh);
< 	else
< 		hangthresh = 0.;
< 
< 	if (a->mode == 0)
< 	{
< 		for (i = 0; i < CXBsize (a->buff); i++)
< 			CXBdata (a->buff, i) = Cscl (CXBdata (a->buff, i), a->gain.fix);
< 		return;
< 	}
< 
< 	for (i = 0; i < CXBsize (a->buff); i++)
< 	{
< 		REAL tmp;
< 		a->circ[a->indx] = CXBdata (a->buff, i);	/* Drop sample into circular buffer */
< 		tmp = Cmag (a->circ[a->indx]);
< 		if (tmp > 0.00000005f)
< 			tmp = a->gain.limit / tmp;	// if not zero sample, calculate gain
< 		else
< 			tmp = a->gain.now;	// update. If zero, then use old gain
< 		if (tmp < hangthresh)
< 			a->hangindex = hangtime;
< 		if (tmp >= a->gain.now)
< 		{
< 			//a->gain.raw = a->one_m_decay * a->gain.now + a->decay * tmp;
< 			if (a->hangindex++ > hangtime)
< 			{
< 				a->gain.now =
< 					a->one_m_decay * a->gain.now +
< 					a->decay * min (a->gain.top, tmp);
< 			}
< 		}
< 		else
< 		{
< 			a->hangindex = 0;
< 			//a->gain.raw = a->one_m_attack * a->gain.now + a->attack * tmp;
< 			a->gain.now =
< 				a->one_m_attack * a->gain.now + a->attack * max (tmp,
< 				a->gain.bottom);
< 		}
< 		tmp = Cmag (a->circ[a->fastindx]);
< 		if (tmp > 0.00000005f)
< 			tmp = a->gain.limit / tmp;
< 		else
< 			tmp = a->gain.fastnow;
< 		if (tmp > a->gain.fastnow)
< 		{
< 			if (a->fasthang++ > fasthangtime)
< 			{
< 				a->gain.fastnow =
< 					min (a->one_m_fastdecay * a->gain.fastnow +
< 					a->fastdecay * min (a->gain.top, tmp), a->gain.top);
< 			}
< 		}
< 		else
< 		{
< 			a->fasthang = 0;
< 			a->gain.fastnow =
< 				max (a->one_m_fastattack * a->gain.fastnow +
< 				a->fastattack * max (tmp, a->gain.bottom), a->gain.bottom);
< 		}
< 		a->gain.fastnow =
< 			max (min (a->gain.fastnow, a->gain.top), a->gain.bottom);
< 		a->gain.now = max (min (a->gain.now, a->gain.top), a->gain.bottom);
< 		CXBdata (a->buff, i) =
< 			Cscl (a->circ[a->sndx],
< 			min (a->gain.fastnow,
< 			min (a->slope * a->gain.now, a->gain.top)));
< 
< 		a->indx = (a->indx + a->mask) & a->mask;
< 		a->sndx = (a->sndx + a->mask) & a->mask;
< 		a->fastindx = (a->fastindx + a->mask) & a->mask;
< 	}
< }
< 
< void
< delDttSPAgc (DTTSPAGC a)
< {
< 	delCXB (a->buff);
< 	delvec_COMPLEX (a->circ);
< 	if (a)
< 		safefree ((char *) a);
< }
---
> 
> void
> DttSPAgc (DTTSPAGC a, int tick)
> {
> 	int i;
> 	int hangtime = (int) (uni[0].samplerate * a->hangtime); // hangtime in samples
> 	int fasthangtime = (int) (uni[0].samplerate * a->fasthangtime); // fast track hangtime in samples
> 
> 	REAL hangthresh; // gate for whether to hang or not
> 
> //	if (a->hangthresh > 0)
> 		hangthresh =
> 			a->gain.top * a->hangthresh + a->gain.bottom * (REAL) (1.0 -
> 			a->hangthresh);
> //	else
> //		hangthresh = 0.;
> 
> 	if (a->mode == 0)
> 	{
> 		for (i = 0; i < CXBsize (a->buff); i++)
> 			CXBdata (a->buff, i) = Cscl (CXBdata (a->buff, i), a->gain.fix);
> 		return;
> 	}
> 
> 	for (i = 0; i < CXBsize (a->buff); i++)
> 	{
> 		REAL tmp;
> 		a->circ[a->slowindx] = CXBdata (a->buff, i);	/* Drop sample into circular buffer */
> 
> 		// first, calculate slow gain
> 		tmp = Cmag (a->circ[a->slowindx]);
> 		if (tmp > 0.0f)
> 			tmp = a->gain.target / tmp;	// if mag(sample) not too small, calculate putative gain
> 										// all the rest of the code which follows is running this
> 										// signal through the control laws.
> 		else
> 			tmp = a->gain.now;	// sample too small, just use old gain
> 		if (tmp < hangthresh)
> 			a->hangindex = hangtime;  // If the gain is less than the current hang threshold, then stop hanging.
> 
> 		if (tmp >= a->gain.now)     // If the putative gain is greater than the current gain then we are in decay.
> 									// That is, we need to "decay the ALC voltage", or increase the gain.
> 		{
> 			//a->gain.raw = a->one_m_decay * a->gain.now + a->decay * tmp;
> 			if (a->hangindex++ > hangtime)  // Have we HUNG around long enough?
> 			{
> 				a->gain.now =  // Compute the applicable slow channel gain through the decay control law.
> 					a->one_m_decay * a->gain.now +
> 					a->decay * min (a->gain.top, tmp);
> 			}
> 		}
> 		else // if the putative gain is greater than the current gain,  we are in attack mode and need to decrease gain 
> 		{
> 			a->hangindex = 0;  // We don't need to hang, we need to attack so we reset the hang index to zero
> 			//a->gain.raw = a->one_m_attack * a->gain.now + a->attack * tmp;
> 			a->gain.now =      // Compute the applicable slow channel gain through the attack control law.
> 				a->one_m_attack * a->gain.now + a->attack * max (tmp,
> 				a->gain.bottom); 
> 		}
> 
> 		// then, calculate fast gain
> 		// Fast channel to handle short duration events and not capture the slow channel decay
> 		tmp = Cmag (a->circ[a->fastindx]);
> 		if (tmp > 0.0f)
> 			tmp = a->gain.target / tmp; // if mag(sample) not too small, calculate putative gain
> 										// all the rest of the code which follows is running this
> 										// signal through the control laws.
> 		else
> 			tmp = a->gain.fastnow;      // too small, just use old gain
> 		if (tmp > a->gain.fastnow)		// If the putative gain is greater than the current gain then we are in decay.
> 										// That is, we need to "decay the ALC voltage", or increase the gain.
> 		{
> 			if (a->fasthang++ > fasthangtime) // Have we HUNG around long enough?
> 			{
> 				a->gain.fastnow =  // Compute the applicable fast channel gain through the decay control law.
> 					a->one_m_fastdecay * a->gain.fastnow +
> 					a->fastdecay * min (a->gain.top, tmp);
> 			}
> 		}
> 		else
> 		{
> 			a->fasthang = 0; // We don't need to hang, we need to attack so we reset the hang index to zero
> 			a->gain.fastnow = // Compute the applicable fast channel gain through the fast attack control law.
> 				a->one_m_fastattack * a->gain.fastnow +
> 				a->fastattack * max (tmp, a->gain.bottom);
> 		}
> 		// Are these two lines necessary? I don't think so.  Let's test that.  tmp is bounded in the statements
> 		// above to be inside the gain limits
> //		a->gain.fastnow =
> //			max (min (a->gain.fastnow, a->gain.top), a->gain.bottom);
> //		a->gain.now = max (min (a->gain.now, a->gain.top), a->gain.bottom);
> 		// Always apply the lower gain.
> 		CXBdata (a->buff, i) =
> 			Cscl (a->circ[a->out_indx],
> 			min (a->gain.fastnow, (a->slope * a->gain.now)));
> 
> 		// Move the indices to prepare for the next sample to be processed
> 		a->slowindx = (a->slowindx + a->mask) & a->mask; 
> 		a->out_indx = (a->out_indx + a->mask) & a->mask;
> 		a->fastindx = (a->fastindx + a->mask) & a->mask;
> 	}
> }
> 
> void
> delDttSPAgc (DTTSPAGC a)
> {
> 	delCXB (a->buff);
> 	delvec_COMPLEX (a->circ);
> 	if (a)
> 		safefree ((char *) a);
> }
diff ./dttspagc.h /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/dttspagc.h
42c42
<     REAL top, now, fastnow, bottom, old, limit, raw, fix;
---
>     REAL top, now, fastnow, bottom, old, target, raw, fix;
56a57
>   REAL *magvec;
59,60c60,61
<   int indx;
<   int sndx;
---
>   int slowindx;
>   int out_indx;
Only in /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP: DttSP.aps
Only in /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP: DttSP.def
Only in /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP: DttSP.rc
Only in /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP: DttSP.vcproj
diff ./fftw3.h /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/fftw3.h
1,383c1,381
< /*
<  * Copyright (c) 2003, 2007-8 Matteo Frigo
<  * Copyright (c) 2003, 2007-8 Massachusetts Institute of Technology
<  *
<  * The following statement of license applies *only* to this header file,
<  * and *not* to the other files distributed with FFTW or derived therefrom:
<  * 
<  * Redistribution and use in source and binary forms, with or without
<  * modification, are permitted provided that the following conditions
<  * are met:
<  *
<  * 1. Redistributions of source code must retain the above copyright
<  *    notice, this list of conditions and the following disclaimer.
<  *
<  * 2. Redistributions in binary form must reproduce the above copyright
<  *    notice, this list of conditions and the following disclaimer in the
<  *    documentation and/or other materials provided with the distribution.
<  *
<  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
<  * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
<  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
<  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
<  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
<  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
<  * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
<  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
<  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<  */
< 
< /***************************** NOTE TO USERS *********************************
<  *
<  *                 THIS IS A HEADER FILE, NOT A MANUAL
<  *
<  *    If you want to know how to use FFTW, please read the manual,
<  *    online at http://www.fftw.org/doc/ and also included with FFTW.
<  *    For a quick start, see the manual's tutorial section.
<  *
<  *   (Reading header files to learn how to use a library is a habit
<  *    stemming from code lacking a proper manual.  Arguably, it's a
<  *    *bad* habit in most cases, because header files can contain
<  *    interfaces that are not part of the public, stable API.)
<  *
<  ****************************************************************************/
< 
< #ifndef FFTW3_H
< #define FFTW3_H
< 
< #include <stdio.h>
< 
< #ifdef __cplusplus
< extern "C"
< {
< #endif /* __cplusplus */
< 
< /* If <complex.h> is included, use the C99 complex type.  Otherwise
<    define a type bit-compatible with C99 complex */
< #if !defined(FFTW_NO_Complex) && defined(_Complex_I) && defined(complex) && defined(I)
< #  define FFTW_DEFINE_COMPLEX(R, C) typedef R _Complex C
< #else
< #  define FFTW_DEFINE_COMPLEX(R, C) typedef R C[2]
< #endif
< 
< #define FFTW_CONCAT(prefix, name) prefix ## name
< #define FFTW_MANGLE_DOUBLE(name) FFTW_CONCAT(fftw_, name)
< #define FFTW_MANGLE_FLOAT(name) FFTW_CONCAT(fftwf_, name)
< #define FFTW_MANGLE_LONG_DOUBLE(name) FFTW_CONCAT(fftwl_, name)
< 
< /* IMPORTANT: for Windows compilers, you should add a line
< */
< #define FFTW_DLL
< /*
<    here and in kernel/ifftw.h if you are compiling/using FFTW as a
<    DLL, in order to do the proper importing/exporting, or
<    alternatively compile with -DFFTW_DLL or the equivalent
<    command-line flag.  This is not necessary under MinGW/Cygwin, where
<    libtool does the imports/exports automatically. */
< #if defined(FFTW_DLL) && (defined(_WIN32) || defined(__WIN32__))
<    /* annoying Windows syntax for shared-library declarations */
< #  if defined(COMPILING_FFTW) /* defined in api.h when compiling FFTW */
< #    define FFTW_EXTERN extern __declspec(dllexport) 
< #  else /* user is calling FFTW; import symbol */
< #    define FFTW_EXTERN extern __declspec(dllimport) 
< #  endif
< #else
< #  define FFTW_EXTERN extern
< #endif
< 
< enum fftw_r2r_kind_do_not_use_me {
<      FFTW_R2HC=0, FFTW_HC2R=1, FFTW_DHT=2,
<      FFTW_REDFT00=3, FFTW_REDFT01=4, FFTW_REDFT10=5, FFTW_REDFT11=6,
<      FFTW_RODFT00=7, FFTW_RODFT01=8, FFTW_RODFT10=9, FFTW_RODFT11=10
< };
< 
< struct fftw_iodim_do_not_use_me {
<      int n;                     /* dimension size */
<      int is;			/* input stride */
<      int os;			/* output stride */
< };
< 
< #include <stddef.h> /* for ptrdiff_t */
< struct fftw_iodim64_do_not_use_me {
<      ptrdiff_t n;                     /* dimension size */
<      ptrdiff_t is;			/* input stride */
<      ptrdiff_t os;			/* output stride */
< };
< 
< /*
<   huge second-order macro that defines prototypes for all API
<   functions.  We expand this macro for each supported precision
<  
<   X: name-mangling macro
<   R: real data type
<   C: complex data type
< */
< 
< #define FFTW_DEFINE_API(X, R, C)					   \
< 									   \
< FFTW_DEFINE_COMPLEX(R, C);						   \
< 									   \
< typedef struct X(plan_s) *X(plan);					   \
< 									   \
< typedef struct fftw_iodim_do_not_use_me X(iodim);			   \
< typedef struct fftw_iodim64_do_not_use_me X(iodim64);			   \
< 									   \
< typedef enum fftw_r2r_kind_do_not_use_me X(r2r_kind);			   \
< 									   \
< FFTW_EXTERN void X(execute)(const X(plan) p);				   \
< 									   \
< FFTW_EXTERN X(plan) X(plan_dft)(int rank, const int *n,			   \
< 		    C *in, C *out, int sign, unsigned flags);		   \
< 									   \
< FFTW_EXTERN X(plan) X(plan_dft_1d)(int n, C *in, C *out, int sign,	   \
< 		       unsigned flags);					   \
< FFTW_EXTERN X(plan) X(plan_dft_2d)(int n0, int n1,			   \
< 		       C *in, C *out, int sign, unsigned flags);	   \
< FFTW_EXTERN X(plan) X(plan_dft_3d)(int n0, int n1, int n2,		   \
< 		       C *in, C *out, int sign, unsigned flags);	   \
< 									   \
< FFTW_EXTERN X(plan) X(plan_many_dft)(int rank, const int *n,		   \
<                          int howmany,					   \
<                          C *in, const int *inembed,			   \
<                          int istride, int idist,			   \
<                          C *out, const int *onembed,			   \
<                          int ostride, int odist,			   \
<                          int sign, unsigned flags);			   \
< 									   \
< FFTW_EXTERN X(plan) X(plan_guru_dft)(int rank, const X(iodim) *dims,	   \
< 			 int howmany_rank,				   \
< 			 const X(iodim) *howmany_dims,			   \
< 			 C *in, C *out,					   \
< 			 int sign, unsigned flags);			   \
< FFTW_EXTERN X(plan) X(plan_guru_split_dft)(int rank, const X(iodim) *dims, \
< 			 int howmany_rank,				   \
< 			 const X(iodim) *howmany_dims,			   \
< 			 R *ri, R *ii, R *ro, R *io,			   \
< 			 unsigned flags);				   \
< 									   \
< FFTW_EXTERN X(plan) X(plan_guru64_dft)(int rank,			   \
<                          const X(iodim64) *dims,			   \
< 			 int howmany_rank,				   \
< 			 const X(iodim64) *howmany_dims,		   \
< 			 C *in, C *out,					   \
< 			 int sign, unsigned flags);			   \
< FFTW_EXTERN X(plan) X(plan_guru64_split_dft)(int rank,			   \
<                          const X(iodim64) *dims,			   \
< 			 int howmany_rank,				   \
< 			 const X(iodim64) *howmany_dims,		   \
< 			 R *ri, R *ii, R *ro, R *io,			   \
< 			 unsigned flags);				   \
< 									   \
< FFTW_EXTERN void X(execute_dft)(const X(plan) p, C *in, C *out);	   \
< FFTW_EXTERN void X(execute_split_dft)(const X(plan) p, R *ri, R *ii,	   \
<                                       R *ro, R *io);			   \
< 									   \
< FFTW_EXTERN X(plan) X(plan_many_dft_r2c)(int rank, const int *n,	   \
<                              int howmany,				   \
<                              R *in, const int *inembed,			   \
<                              int istride, int idist,			   \
<                              C *out, const int *onembed,		   \
<                              int ostride, int odist,			   \
<                              unsigned flags);				   \
< 									   \
< FFTW_EXTERN X(plan) X(plan_dft_r2c)(int rank, const int *n,		   \
<                         R *in, C *out, unsigned flags);			   \
< 									   \
< FFTW_EXTERN X(plan) X(plan_dft_r2c_1d)(int n,R *in,C *out,unsigned flags); \
< FFTW_EXTERN X(plan) X(plan_dft_r2c_2d)(int n0, int n1,			   \
< 			   R *in, C *out, unsigned flags);		   \
< FFTW_EXTERN X(plan) X(plan_dft_r2c_3d)(int n0, int n1,			   \
< 			   int n2,					   \
< 			   R *in, C *out, unsigned flags);		   \
< 									   \
< 									   \
< FFTW_EXTERN X(plan) X(plan_many_dft_c2r)(int rank, const int *n,	   \
< 			     int howmany,				   \
< 			     C *in, const int *inembed,			   \
< 			     int istride, int idist,			   \
< 			     R *out, const int *onembed,		   \
< 			     int ostride, int odist,			   \
< 			     unsigned flags);				   \
< 									   \
< FFTW_EXTERN X(plan) X(plan_dft_c2r)(int rank, const int *n,		   \
<                         C *in, R *out, unsigned flags);			   \
< 									   \
< FFTW_EXTERN X(plan) X(plan_dft_c2r_1d)(int n,C *in,R *out,unsigned flags); \
< FFTW_EXTERN X(plan) X(plan_dft_c2r_2d)(int n0, int n1,			   \
< 			   C *in, R *out, unsigned flags);		   \
< FFTW_EXTERN X(plan) X(plan_dft_c2r_3d)(int n0, int n1,			   \
< 			   int n2,					   \
< 			   C *in, R *out, unsigned flags);		   \
< 									   \
< FFTW_EXTERN X(plan) X(plan_guru_dft_r2c)(int rank, const X(iodim) *dims,   \
< 			     int howmany_rank,				   \
< 			     const X(iodim) *howmany_dims,		   \
< 			     R *in, C *out,				   \
< 			     unsigned flags);				   \
< FFTW_EXTERN X(plan) X(plan_guru_dft_c2r)(int rank, const X(iodim) *dims,   \
< 			     int howmany_rank,				   \
< 			     const X(iodim) *howmany_dims,		   \
< 			     C *in, R *out,				   \
< 			     unsigned flags);				   \
< 									   \
< FFTW_EXTERN X(plan) X(plan_guru_split_dft_r2c)(				   \
<                              int rank, const X(iodim) *dims,		   \
< 			     int howmany_rank,				   \
< 			     const X(iodim) *howmany_dims,		   \
< 			     R *in, R *ro, R *io,			   \
< 			     unsigned flags);				   \
< FFTW_EXTERN X(plan) X(plan_guru_split_dft_c2r)(				   \
<                              int rank, const X(iodim) *dims,		   \
< 			     int howmany_rank,				   \
< 			     const X(iodim) *howmany_dims,		   \
< 			     R *ri, R *ii, R *out,			   \
< 			     unsigned flags);				   \
< 									   \
< FFTW_EXTERN X(plan) X(plan_guru64_dft_r2c)(int rank,			   \
<                              const X(iodim64) *dims,			   \
< 			     int howmany_rank,				   \
< 			     const X(iodim64) *howmany_dims,		   \
< 			     R *in, C *out,				   \
< 			     unsigned flags);				   \
< FFTW_EXTERN X(plan) X(plan_guru64_dft_c2r)(int rank,			   \
<                              const X(iodim64) *dims,			   \
< 			     int howmany_rank,				   \
< 			     const X(iodim64) *howmany_dims,		   \
< 			     C *in, R *out,				   \
< 			     unsigned flags);				   \
< 									   \
< FFTW_EXTERN X(plan) X(plan_guru64_split_dft_r2c)(			   \
<                              int rank, const X(iodim64) *dims,		   \
< 			     int howmany_rank,				   \
< 			     const X(iodim64) *howmany_dims,		   \
< 			     R *in, R *ro, R *io,			   \
< 			     unsigned flags);				   \
< FFTW_EXTERN X(plan) X(plan_guru64_split_dft_c2r)(			   \
<                              int rank, const X(iodim64) *dims,		   \
< 			     int howmany_rank,				   \
< 			     const X(iodim64) *howmany_dims,		   \
< 			     R *ri, R *ii, R *out,			   \
< 			     unsigned flags);				   \
< 									   \
< FFTW_EXTERN void X(execute_dft_r2c)(const X(plan) p, R *in, C *out);	   \
< FFTW_EXTERN void X(execute_dft_c2r)(const X(plan) p, C *in, R *out);	   \
< 									   \
< FFTW_EXTERN void X(execute_split_dft_r2c)(const X(plan) p,		   \
<                                           R *in, R *ro, R *io);		   \
< FFTW_EXTERN void X(execute_split_dft_c2r)(const X(plan) p,		   \
<                                           R *ri, R *ii, R *out);	   \
< 									   \
< FFTW_EXTERN X(plan) X(plan_many_r2r)(int rank, const int *n,		   \
<                          int howmany,					   \
<                          R *in, const int *inembed,			   \
<                          int istride, int idist,			   \
<                          R *out, const int *onembed,			   \
<                          int ostride, int odist,			   \
<                          const X(r2r_kind) *kind, unsigned flags);	   \
< 									   \
< FFTW_EXTERN X(plan) X(plan_r2r)(int rank, const int *n, R *in, R *out,	   \
<                     const X(r2r_kind) *kind, unsigned flags);		   \
< 									   \
< FFTW_EXTERN X(plan) X(plan_r2r_1d)(int n, R *in, R *out,		   \
<                        X(r2r_kind) kind, unsigned flags);		   \
< FFTW_EXTERN X(plan) X(plan_r2r_2d)(int n0, int n1, R *in, R *out,	   \
<                        X(r2r_kind) kind0, X(r2r_kind) kind1,		   \
<                        unsigned flags);					   \
< FFTW_EXTERN X(plan) X(plan_r2r_3d)(int n0, int n1, int n2,		   \
<                        R *in, R *out, X(r2r_kind) kind0,		   \
<                        X(r2r_kind) kind1, X(r2r_kind) kind2,		   \
<                        unsigned flags);					   \
< 									   \
< FFTW_EXTERN X(plan) X(plan_guru_r2r)(int rank, const X(iodim) *dims,	   \
<                          int howmany_rank,				   \
<                          const X(iodim) *howmany_dims,			   \
<                          R *in, R *out,					   \
<                          const X(r2r_kind) *kind, unsigned flags);	   \
< 									   \
< FFTW_EXTERN X(plan) X(plan_guru64_r2r)(int rank, const X(iodim64) *dims,   \
<                          int howmany_rank,				   \
<                          const X(iodim64) *howmany_dims,		   \
<                          R *in, R *out,					   \
<                          const X(r2r_kind) *kind, unsigned flags);	   \
< 									   \
< FFTW_EXTERN void X(execute_r2r)(const X(plan) p, R *in, R *out);	   \
< 									   \
< FFTW_EXTERN void X(destroy_plan)(X(plan) p);				   \
< FFTW_EXTERN void X(forget_wisdom)(void);				   \
< FFTW_EXTERN void X(cleanup)(void);					   \
< 									   \
< FFTW_EXTERN void X(set_timelimit)(double);				   \
< 									   \
< FFTW_EXTERN void X(plan_with_nthreads)(int nthreads);			   \
< FFTW_EXTERN int X(init_threads)(void);					   \
< FFTW_EXTERN void X(cleanup_threads)(void);				   \
< 									   \
< FFTW_EXTERN void X(export_wisdom_to_file)(FILE *output_file);		   \
< FFTW_EXTERN char *X(export_wisdom_to_string)(void);			   \
< FFTW_EXTERN void X(export_wisdom)(void (*write_char)(char c, void *),	   \
<                                   void *data);				   \
< FFTW_EXTERN int X(import_system_wisdom)(void);				   \
< FFTW_EXTERN int X(import_wisdom_from_file)(FILE *input_file);		   \
< FFTW_EXTERN int X(import_wisdom_from_string)(const char *input_string);	   \
< FFTW_EXTERN int X(import_wisdom)(int (*read_char)(void *), void *data);	   \
< 									   \
< FFTW_EXTERN void X(fprint_plan)(const X(plan) p, FILE *output_file);	   \
< FFTW_EXTERN void X(print_plan)(const X(plan) p);			   \
< 									   \
< FFTW_EXTERN void *X(malloc)(size_t n);					   \
< FFTW_EXTERN void X(free)(void *p);					   \
< 									   \
< FFTW_EXTERN void X(flops)(const X(plan) p,				   \
<                           double *add, double *mul, double *fmas);	   \
< FFTW_EXTERN double X(estimate_cost)(const X(plan) p);			   \
< 									   \
< FFTW_EXTERN const char X(version)[];					   \
< FFTW_EXTERN const char X(cc)[];						   \
< FFTW_EXTERN const char X(codelet_optim)[];
< 
< 
< /* end of FFTW_DEFINE_API macro */
< 
< FFTW_DEFINE_API(FFTW_MANGLE_DOUBLE, double, fftw_complex)
< FFTW_DEFINE_API(FFTW_MANGLE_FLOAT, float, fftwf_complex)
< FFTW_DEFINE_API(FFTW_MANGLE_LONG_DOUBLE, long double, fftwl_complex)
< 
< #define FFTW_FORWARD (-1)
< #define FFTW_BACKWARD (+1)
< 
< #define FFTW_NO_TIMELIMIT (-1.0)
< 
< /* documented flags */
< #define FFTW_MEASURE (0U)
< #define FFTW_DESTROY_INPUT (1U << 0)
< #define FFTW_UNALIGNED (1U << 1)
< #define FFTW_CONSERVE_MEMORY (1U << 2)
< #define FFTW_EXHAUSTIVE (1U << 3) /* NO_EXHAUSTIVE is default */
< #define FFTW_PRESERVE_INPUT (1U << 4) /* cancels FFTW_DESTROY_INPUT */
< #define FFTW_PATIENT (1U << 5) /* IMPATIENT is default */
< #define FFTW_ESTIMATE (1U << 6)
< 
< /* undocumented beyond-guru flags */
< #define FFTW_ESTIMATE_PATIENT (1U << 7)
< #define FFTW_BELIEVE_PCOST (1U << 8)
< #define FFTW_NO_DFT_R2HC (1U << 9)
< #define FFTW_NO_NONTHREADED (1U << 10)
< #define FFTW_NO_BUFFERING (1U << 11)
< #define FFTW_NO_INDIRECT_OP (1U << 12)
< #define FFTW_ALLOW_LARGE_GENERIC (1U << 13) /* NO_LARGE_GENERIC is default */
< #define FFTW_NO_RANK_SPLITS (1U << 14)
< #define FFTW_NO_VRANK_SPLITS (1U << 15)
< #define FFTW_NO_VRECURSE (1U << 16)
< #define FFTW_NO_SIMD (1U << 17)
< #define FFTW_NO_SLOW (1U << 18)
< #define FFTW_NO_FIXED_RADIX_LARGE_N (1U << 19)
< #define FFTW_ALLOW_PRUNING (1U << 20)
< #define FFTW_WISDOM_ONLY (1U << 21)
< 
< #ifdef __cplusplus
< }  /* extern "C" */
< #endif /* __cplusplus */
< 
< #endif /* FFTW3_H */
---
> /*
>  * Copyright (c) 2003, 2007-8 Matteo Frigo
>  * Copyright (c) 2003, 2007-8 Massachusetts Institute of Technology
>  *
>  * The following statement of license applies *only* to this header file,
>  * and *not* to the other files distributed with FFTW or derived therefrom:
>  * 
>  * Redistribution and use in source and binary forms, with or without
>  * modification, are permitted provided that the following conditions
>  * are met:
>  *
>  * 1. Redistributions of source code must retain the above copyright
>  *    notice, this list of conditions and the following disclaimer.
>  *
>  * 2. Redistributions in binary form must reproduce the above copyright
>  *    notice, this list of conditions and the following disclaimer in the
>  *    documentation and/or other materials provided with the distribution.
>  *
>  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
>  * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
>  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
>  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
>  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
>  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
>  * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
>  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
>  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
>  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
>  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
>  */
> 
> /***************************** NOTE TO USERS *********************************
>  *
>  *                 THIS IS A HEADER FILE, NOT A MANUAL
>  *
>  *    If you want to know how to use FFTW, please read the manual,
>  *    online at http://www.fftw.org/doc/ and also included with FFTW.
>  *    For a quick start, see the manual's tutorial section.
>  *
>  *   (Reading header files to learn how to use a library is a habit
>  *    stemming from code lacking a proper manual.  Arguably, it's a
>  *    *bad* habit in most cases, because header files can contain
>  *    interfaces that are not part of the public, stable API.)
>  *
>  ****************************************************************************/
> 
> #ifndef FFTW3_H
> #define FFTW3_H
> 
> #include <stdio.h>
> 
> #ifdef __cplusplus
> extern "C"
> {
> #endif /* __cplusplus */
> 
> /* If <complex.h> is included, use the C99 complex type.  Otherwise
>    define a type bit-compatible with C99 complex */
> #if !defined(FFTW_NO_Complex) && defined(_Complex_I) && defined(complex) && defined(I)
> #  define FFTW_DEFINE_COMPLEX(R, C) typedef R _Complex C
> #else
> #  define FFTW_DEFINE_COMPLEX(R, C) typedef R C[2]
> #endif
> 
> #define FFTW_CONCAT(prefix, name) prefix ## name
> #define FFTW_MANGLE_DOUBLE(name) FFTW_CONCAT(fftw_, name)
> #define FFTW_MANGLE_FLOAT(name) FFTW_CONCAT(fftwf_, name)
> #define FFTW_MANGLE_LONG_DOUBLE(name) FFTW_CONCAT(fftwl_, name)
> #define FFTW_DLL
> 
> /* IMPORTANT: for Windows compilers, you should add a line
>    here and in kernel/ifftw.h if you are compiling/using FFTW as a
>    DLL, in order to do the proper importing/exporting, or
>    alternatively compile with -DFFTW_DLL or the equivalent
>    command-line flag.  This is not necessary under MinGW/Cygwin, where
>    libtool does the imports/exports automatically. */
> #if defined(FFTW_DLL) && (defined(_WIN32) || defined(__WIN32__))
>    /* annoying Windows syntax for shared-library declarations */
> #  if defined(COMPILING_FFTW) /* defined in api.h when compiling FFTW */
> #    define FFTW_EXTERN extern __declspec(dllexport) 
> #  else /* user is calling FFTW; import symbol */
> #    define FFTW_EXTERN extern __declspec(dllimport) 
> #  endif
> #else
> #  define FFTW_EXTERN extern
> #endif
> 
> enum fftw_r2r_kind_do_not_use_me {
>      FFTW_R2HC=0, FFTW_HC2R=1, FFTW_DHT=2,
>      FFTW_REDFT00=3, FFTW_REDFT01=4, FFTW_REDFT10=5, FFTW_REDFT11=6,
>      FFTW_RODFT00=7, FFTW_RODFT01=8, FFTW_RODFT10=9, FFTW_RODFT11=10
> };
> 
> struct fftw_iodim_do_not_use_me {
>      int n;                     /* dimension size */
>      int is;			/* input stride */
>      int os;			/* output stride */
> };
> 
> #include <stddef.h> /* for ptrdiff_t */
> struct fftw_iodim64_do_not_use_me {
>      ptrdiff_t n;                     /* dimension size */
>      ptrdiff_t is;			/* input stride */
>      ptrdiff_t os;			/* output stride */
> };
> 
> /*
>   huge second-order macro that defines prototypes for all API
>   functions.  We expand this macro for each supported precision
>  
>   X: name-mangling macro
>   R: real data type
>   C: complex data type
> */
> 
> #define FFTW_DEFINE_API(X, R, C)					   \
> 									   \
> FFTW_DEFINE_COMPLEX(R, C);						   \
> 									   \
> typedef struct X(plan_s) *X(plan);					   \
> 									   \
> typedef struct fftw_iodim_do_not_use_me X(iodim);			   \
> typedef struct fftw_iodim64_do_not_use_me X(iodim64);			   \
> 									   \
> typedef enum fftw_r2r_kind_do_not_use_me X(r2r_kind);			   \
> 									   \
> FFTW_EXTERN void X(execute)(const X(plan) p);				   \
> 									   \
> FFTW_EXTERN X(plan) X(plan_dft)(int rank, const int *n,			   \
> 		    C *in, C *out, int sign, unsigned flags);		   \
> 									   \
> FFTW_EXTERN X(plan) X(plan_dft_1d)(int n, C *in, C *out, int sign,	   \
> 		       unsigned flags);					   \
> FFTW_EXTERN X(plan) X(plan_dft_2d)(int n0, int n1,			   \
> 		       C *in, C *out, int sign, unsigned flags);	   \
> FFTW_EXTERN X(plan) X(plan_dft_3d)(int n0, int n1, int n2,		   \
> 		       C *in, C *out, int sign, unsigned flags);	   \
> 									   \
> FFTW_EXTERN X(plan) X(plan_many_dft)(int rank, const int *n,		   \
>                          int howmany,					   \
>                          C *in, const int *inembed,			   \
>                          int istride, int idist,			   \
>                          C *out, const int *onembed,			   \
>                          int ostride, int odist,			   \
>                          int sign, unsigned flags);			   \
> 									   \
> FFTW_EXTERN X(plan) X(plan_guru_dft)(int rank, const X(iodim) *dims,	   \
> 			 int howmany_rank,				   \
> 			 const X(iodim) *howmany_dims,			   \
> 			 C *in, C *out,					   \
> 			 int sign, unsigned flags);			   \
> FFTW_EXTERN X(plan) X(plan_guru_split_dft)(int rank, const X(iodim) *dims, \
> 			 int howmany_rank,				   \
> 			 const X(iodim) *howmany_dims,			   \
> 			 R *ri, R *ii, R *ro, R *io,			   \
> 			 unsigned flags);				   \
> 									   \
> FFTW_EXTERN X(plan) X(plan_guru64_dft)(int rank,			   \
>                          const X(iodim64) *dims,			   \
> 			 int howmany_rank,				   \
> 			 const X(iodim64) *howmany_dims,		   \
> 			 C *in, C *out,					   \
> 			 int sign, unsigned flags);			   \
> FFTW_EXTERN X(plan) X(plan_guru64_split_dft)(int rank,			   \
>                          const X(iodim64) *dims,			   \
> 			 int howmany_rank,				   \
> 			 const X(iodim64) *howmany_dims,		   \
> 			 R *ri, R *ii, R *ro, R *io,			   \
> 			 unsigned flags);				   \
> 									   \
> FFTW_EXTERN void X(execute_dft)(const X(plan) p, C *in, C *out);	   \
> FFTW_EXTERN void X(execute_split_dft)(const X(plan) p, R *ri, R *ii,	   \
>                                       R *ro, R *io);			   \
> 									   \
> FFTW_EXTERN X(plan) X(plan_many_dft_r2c)(int rank, const int *n,	   \
>                              int howmany,				   \
>                              R *in, const int *inembed,			   \
>                              int istride, int idist,			   \
>                              C *out, const int *onembed,		   \
>                              int ostride, int odist,			   \
>                              unsigned flags);				   \
> 									   \
> FFTW_EXTERN X(plan) X(plan_dft_r2c)(int rank, const int *n,		   \
>                         R *in, C *out, unsigned flags);			   \
> 									   \
> FFTW_EXTERN X(plan) X(plan_dft_r2c_1d)(int n,R *in,C *out,unsigned flags); \
> FFTW_EXTERN X(plan) X(plan_dft_r2c_2d)(int n0, int n1,			   \
> 			   R *in, C *out, unsigned flags);		   \
> FFTW_EXTERN X(plan) X(plan_dft_r2c_3d)(int n0, int n1,			   \
> 			   int n2,					   \
> 			   R *in, C *out, unsigned flags);		   \
> 									   \
> 									   \
> FFTW_EXTERN X(plan) X(plan_many_dft_c2r)(int rank, const int *n,	   \
> 			     int howmany,				   \
> 			     C *in, const int *inembed,			   \
> 			     int istride, int idist,			   \
> 			     R *out, const int *onembed,		   \
> 			     int ostride, int odist,			   \
> 			     unsigned flags);				   \
> 									   \
> FFTW_EXTERN X(plan) X(plan_dft_c2r)(int rank, const int *n,		   \
>                         C *in, R *out, unsigned flags);			   \
> 									   \
> FFTW_EXTERN X(plan) X(plan_dft_c2r_1d)(int n,C *in,R *out,unsigned flags); \
> FFTW_EXTERN X(plan) X(plan_dft_c2r_2d)(int n0, int n1,			   \
> 			   C *in, R *out, unsigned flags);		   \
> FFTW_EXTERN X(plan) X(plan_dft_c2r_3d)(int n0, int n1,			   \
> 			   int n2,					   \
> 			   C *in, R *out, unsigned flags);		   \
> 									   \
> FFTW_EXTERN X(plan) X(plan_guru_dft_r2c)(int rank, const X(iodim) *dims,   \
> 			     int howmany_rank,				   \
> 			     const X(iodim) *howmany_dims,		   \
> 			     R *in, C *out,				   \
> 			     unsigned flags);				   \
> FFTW_EXTERN X(plan) X(plan_guru_dft_c2r)(int rank, const X(iodim) *dims,   \
> 			     int howmany_rank,				   \
> 			     const X(iodim) *howmany_dims,		   \
> 			     C *in, R *out,				   \
> 			     unsigned flags);				   \
> 									   \
> FFTW_EXTERN X(plan) X(plan_guru_split_dft_r2c)(				   \
>                              int rank, const X(iodim) *dims,		   \
> 			     int howmany_rank,				   \
> 			     const X(iodim) *howmany_dims,		   \
> 			     R *in, R *ro, R *io,			   \
> 			     unsigned flags);				   \
> FFTW_EXTERN X(plan) X(plan_guru_split_dft_c2r)(				   \
>                              int rank, const X(iodim) *dims,		   \
> 			     int howmany_rank,				   \
> 			     const X(iodim) *howmany_dims,		   \
> 			     R *ri, R *ii, R *out,			   \
> 			     unsigned flags);				   \
> 									   \
> FFTW_EXTERN X(plan) X(plan_guru64_dft_r2c)(int rank,			   \
>                              const X(iodim64) *dims,			   \
> 			     int howmany_rank,				   \
> 			     const X(iodim64) *howmany_dims,		   \
> 			     R *in, C *out,				   \
> 			     unsigned flags);				   \
> FFTW_EXTERN X(plan) X(plan_guru64_dft_c2r)(int rank,			   \
>                              const X(iodim64) *dims,			   \
> 			     int howmany_rank,				   \
> 			     const X(iodim64) *howmany_dims,		   \
> 			     C *in, R *out,				   \
> 			     unsigned flags);				   \
> 									   \
> FFTW_EXTERN X(plan) X(plan_guru64_split_dft_r2c)(			   \
>                              int rank, const X(iodim64) *dims,		   \
> 			     int howmany_rank,				   \
> 			     const X(iodim64) *howmany_dims,		   \
> 			     R *in, R *ro, R *io,			   \
> 			     unsigned flags);				   \
> FFTW_EXTERN X(plan) X(plan_guru64_split_dft_c2r)(			   \
>                              int rank, const X(iodim64) *dims,		   \
> 			     int howmany_rank,				   \
> 			     const X(iodim64) *howmany_dims,		   \
> 			     R *ri, R *ii, R *out,			   \
> 			     unsigned flags);				   \
> 									   \
> FFTW_EXTERN void X(execute_dft_r2c)(const X(plan) p, R *in, C *out);	   \
> FFTW_EXTERN void X(execute_dft_c2r)(const X(plan) p, C *in, R *out);	   \
> 									   \
> FFTW_EXTERN void X(execute_split_dft_r2c)(const X(plan) p,		   \
>                                           R *in, R *ro, R *io);		   \
> FFTW_EXTERN void X(execute_split_dft_c2r)(const X(plan) p,		   \
>                                           R *ri, R *ii, R *out);	   \
> 									   \
> FFTW_EXTERN X(plan) X(plan_many_r2r)(int rank, const int *n,		   \
>                          int howmany,					   \
>                          R *in, const int *inembed,			   \
>                          int istride, int idist,			   \
>                          R *out, const int *onembed,			   \
>                          int ostride, int odist,			   \
>                          const X(r2r_kind) *kind, unsigned flags);	   \
> 									   \
> FFTW_EXTERN X(plan) X(plan_r2r)(int rank, const int *n, R *in, R *out,	   \
>                     const X(r2r_kind) *kind, unsigned flags);		   \
> 									   \
> FFTW_EXTERN X(plan) X(plan_r2r_1d)(int n, R *in, R *out,		   \
>                        X(r2r_kind) kind, unsigned flags);		   \
> FFTW_EXTERN X(plan) X(plan_r2r_2d)(int n0, int n1, R *in, R *out,	   \
>                        X(r2r_kind) kind0, X(r2r_kind) kind1,		   \
>                        unsigned flags);					   \
> FFTW_EXTERN X(plan) X(plan_r2r_3d)(int n0, int n1, int n2,		   \
>                        R *in, R *out, X(r2r_kind) kind0,		   \
>                        X(r2r_kind) kind1, X(r2r_kind) kind2,		   \
>                        unsigned flags);					   \
> 									   \
> FFTW_EXTERN X(plan) X(plan_guru_r2r)(int rank, const X(iodim) *dims,	   \
>                          int howmany_rank,				   \
>                          const X(iodim) *howmany_dims,			   \
>                          R *in, R *out,					   \
>                          const X(r2r_kind) *kind, unsigned flags);	   \
> 									   \
> FFTW_EXTERN X(plan) X(plan_guru64_r2r)(int rank, const X(iodim64) *dims,   \
>                          int howmany_rank,				   \
>                          const X(iodim64) *howmany_dims,		   \
>                          R *in, R *out,					   \
>                          const X(r2r_kind) *kind, unsigned flags);	   \
> 									   \
> FFTW_EXTERN void X(execute_r2r)(const X(plan) p, R *in, R *out);	   \
> 									   \
> FFTW_EXTERN void X(destroy_plan)(X(plan) p);				   \
> FFTW_EXTERN void X(forget_wisdom)(void);				   \
> FFTW_EXTERN void X(cleanup)(void);					   \
> 									   \
> FFTW_EXTERN void X(set_timelimit)(double);				   \
> 									   \
> FFTW_EXTERN void X(plan_with_nthreads)(int nthreads);			   \
> FFTW_EXTERN int X(init_threads)(void);					   \
> FFTW_EXTERN void X(cleanup_threads)(void);				   \
> 									   \
> FFTW_EXTERN void X(export_wisdom_to_file)(FILE *output_file);		   \
> FFTW_EXTERN char *X(export_wisdom_to_string)(void);			   \
> FFTW_EXTERN void X(export_wisdom)(void (*write_char)(char c, void *),	   \
>                                   void *data);				   \
> FFTW_EXTERN int X(import_system_wisdom)(void);				   \
> FFTW_EXTERN int X(import_wisdom_from_file)(FILE *input_file);		   \
> FFTW_EXTERN int X(import_wisdom_from_string)(const char *input_string);	   \
> FFTW_EXTERN int X(import_wisdom)(int (*read_char)(void *), void *data);	   \
> 									   \
> FFTW_EXTERN void X(fprint_plan)(const X(plan) p, FILE *output_file);	   \
> FFTW_EXTERN void X(print_plan)(const X(plan) p);			   \
> 									   \
> FFTW_EXTERN void *X(malloc)(size_t n);					   \
> FFTW_EXTERN void X(free)(void *p);					   \
> 									   \
> FFTW_EXTERN void X(flops)(const X(plan) p,				   \
>                           double *add, double *mul, double *fmas);	   \
> FFTW_EXTERN double X(estimate_cost)(const X(plan) p);			   \
> 									   \
> FFTW_EXTERN const char X(version)[];					   \
> FFTW_EXTERN const char X(cc)[];						   \
> FFTW_EXTERN const char X(codelet_optim)[];
> 
> 
> /* end of FFTW_DEFINE_API macro */
> 
> FFTW_DEFINE_API(FFTW_MANGLE_DOUBLE, double, fftw_complex)
> FFTW_DEFINE_API(FFTW_MANGLE_FLOAT, float, fftwf_complex)
> FFTW_DEFINE_API(FFTW_MANGLE_LONG_DOUBLE, long double, fftwl_complex)
> 
> #define FFTW_FORWARD (-1)
> #define FFTW_BACKWARD (+1)
> 
> #define FFTW_NO_TIMELIMIT (-1.0)
> 
> /* documented flags */
> #define FFTW_MEASURE (0U)
> #define FFTW_DESTROY_INPUT (1U << 0)
> #define FFTW_UNALIGNED (1U << 1)
> #define FFTW_CONSERVE_MEMORY (1U << 2)
> #define FFTW_EXHAUSTIVE (1U << 3) /* NO_EXHAUSTIVE is default */
> #define FFTW_PRESERVE_INPUT (1U << 4) /* cancels FFTW_DESTROY_INPUT */
> #define FFTW_PATIENT (1U << 5) /* IMPATIENT is default */
> #define FFTW_ESTIMATE (1U << 6)
> 
> /* undocumented beyond-guru flags */
> #define FFTW_ESTIMATE_PATIENT (1U << 7)
> #define FFTW_BELIEVE_PCOST (1U << 8)
> #define FFTW_NO_DFT_R2HC (1U << 9)
> #define FFTW_NO_NONTHREADED (1U << 10)
> #define FFTW_NO_BUFFERING (1U << 11)
> #define FFTW_NO_INDIRECT_OP (1U << 12)
> #define FFTW_ALLOW_LARGE_GENERIC (1U << 13) /* NO_LARGE_GENERIC is default */
> #define FFTW_NO_RANK_SPLITS (1U << 14)
> #define FFTW_NO_VRANK_SPLITS (1U << 15)
> #define FFTW_NO_VRECURSE (1U << 16)
> #define FFTW_NO_SIMD (1U << 17)
> #define FFTW_NO_SLOW (1U << 18)
> #define FFTW_NO_FIXED_RADIX_LARGE_N (1U << 19)
> #define FFTW_ALLOW_PRUNING (1U << 20)
> #define FFTW_WISDOM_ONLY (1U << 21)
> 
> #ifdef __cplusplus
> }  /* extern "C" */
> #endif /* __cplusplus */
> 
> #endif /* FFTW3_H */
Only in /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP: files
diff ./fromsys.h /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/fromsys.h
42,43c42,43
< //#include <winsock2.h>
< //#include <windows.h>
---
> #include <winsock2.h>
> #include <windows.h>
52,55c52,53
< //#define DttSP_EXP __declspec(dllexport)
< //#define DttSP_IMP __declspec(dllimport)
< #define DttSP_EXP
< #define DttSP_IMP
---
> #define DttSP_EXP __declspec(dllexport)
> #define DttSP_IMP __declspec(dllimport)
73d70
< #ifdef DONT_INCLUDE
98,99c95,96
< 	 _tzset ();
< 	 tzflag++;
---
> 	  _tzset ();
> 	  tzflag++;
107d103
< #endif
109c105
< //#define snprintf _snprintf
---
> #define snprintf _snprintf
diff ./keyd.c /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/keyd.c
47,48c47,48
< //#include <windows.h>
< //#include <MMsystem.h>
---
> #include <windows.h>
> #include <MMsystem.h>
61d60
< BOOLEAN HiPerformance = FALSE;
70c69
< #define RING_SIZE 8192
---
> #define RING_SIZE 4096
86a86,88
> static BOOLEAN mid_element = TRUE;
> static BOOLEAN auto_space_char = FALSE;
> 
89a92
> static int count = 0;
98c101
< 		size_t reset_size = (unsigned)nframes;
---
> 		size_t reset_size = 0;//(unsigned)nframes;
110c113,114
< 	if ((numsamps = ringb_float_read_space (lring)) < (size_t) nframes)
---
> 
> 	if ((numsamps = ringb_float_read_space (lring)) < (size_t) nframes) // underflow condition
112,114c116,135
< 		memset (bufl, 0, bytesize);
< 		memset (bufr, 0, bytesize);
< 		cw_ring_reset = TRUE;
---
> 		if(numsamps < (size_t)nframes/2) // not enough in the buffer, just send zeros and wait for next callback
> 		{
> 			memset (bufl, 0, bytesize);
> 			memset (bufr, 0, bytesize);
> 		}
> 		else // pad with zeros and leave nframes/2 in the ring buffer, send rest
> 		{
> 			int num_to_read = numsamps - nframes/2;
> 			int num_to_zero = nframes - num_to_read;
> 
> 			memset(bufl, 0, sizeof(float)*num_to_zero);
> 			memset(bufr, 0, sizeof(float)*num_to_zero);
> 
> 			EnterCriticalSection (cs_cw);
> 			ringb_float_read (lring, bufl+num_to_read, num_to_read);
> 			ringb_float_read (rring, bufr+num_to_read, num_to_read);
> 			LeaveCriticalSection (cs_cw);
> 		}
> 		//fprintf(stdout, "CWtoneExchange: cw_ring_reset = TRUE\n"), fflush(stdout);
> 		//cw_ring_reset = TRUE;
116c137
< 	else
---
> 	else // normal condition
122c143,149
< 	}	
---
> 	}
> 
> 	if(numsamps > 3.5*nframes) // keep ring buffer from growing too much
> 		cw_ring_reset = TRUE;
> 
> 	/*if(count++ % 100 == 0)
> 		fprintf(stdout, "cw buf: %u\n", numsamps), fflush(stdout);*/
128c155
< {  
---
> {
130a158
> 		//fprintf(stdout, "send_tone: cw_ring_reset = TRUE\n"), fflush(stdout);
137c165
< 		correctIQ(gen->buf, tx[1].iqfix);
---
> 		correctIQ(gen->buf, tx[1].iqfix, TRUE,0);
154a183
> 		//fprintf(stdout, "send_silence: cw_ring_reset = TRUE\n"), fflush(stdout);
334a364,383
> SetKeyerAutoSpace (BOOLEAN setit)
> {
> 	//fprintf(stdout, "SetKeyerAutoSpace(%u)\n",setit), fflush(stdout);
> 	EnterCriticalSection(update_ok);
> 	auto_space_char = setit;
> 	ks->flag.autospace.khar = setit;		
> 	LeaveCriticalSection(update_ok);
> }
> 
> DttSP_EXP void
> SetKeyerModeBStrict (BOOLEAN setit)
> {
> 	//fprintf(stdout, "SetKeyerModeBStrict(%u)\n",setit), fflush(stdout);
> 	EnterCriticalSection(update_ok);
> 	mid_element = setit;
> 	ks->flag.mdlmdB = setit;
> 	LeaveCriticalSection(update_ok);
> }
> 
> DttSP_EXP void
343a393,402
> SetKeyerHarmonicRemove(double harmonic, double phase, double amplitude)
> {
> 	EnterCriticalSection(update_ok);
> 	gen->amplitude =  amplitude;
> 	gen->harmonic = harmonic;
> 	gen->phase =  phase;
> 	LeaveCriticalSection(update_ok);
> }
> 
> DttSP_EXP void
372c431
< 			ks->flag.mdlmdB = FALSE;
---
> 			//ks->flag.mdlmdB = FALSE;
376c435
< 			ks->flag.mdlmdB = TRUE;
---
> 			//ks->flag.mdlmdB = TRUE;  //checkbox added
413a473
> #if 0
428,439c488,491
< 	if (hiperf)
< 	{
< 		HiPerformance = TRUE;
< 		key_poll_period = 1;
< 		TONE_SIZE = 48;
< 	}
< 	else
< 	{
< 		HiPerformance = FALSE;
< 		key_poll_period = 5;
< 		TONE_SIZE = 240;
< 	}
---
> 
> 	key_poll_period = 1;
> 	TONE_SIZE = 48;
> 
457a510
> #endif // if 0
468,469c521,523
< 	ks->flag.autospace.khar = ks->flag.autospace.word = FALSE;
< 	ks->flag.mdlmdB = TRUE;
---
> 	ks->flag.autospace.khar = auto_space_char;	//this option is now selectable
> 	ks->flag.autospace.word = FALSE;
> 	ks->flag.mdlmdB = mid_element;	//this option is now selectable
490,499c544,547
< 	if (HiPerformance)
< 	{
< 		key_poll_period = 1;
< 		TONE_SIZE = 48 * (int) (uni[0].samplerate / 48000.0);
< 	}
< 	else
< 	{
< 		key_poll_period = 5;
< 		TONE_SIZE = 240 * (int) (uni[0].samplerate / 48000.0);
< 	}
---
> 
> 	key_poll_period = 1;
> 	TONE_SIZE = 48 * (int) (uni[0].samplerate / 48000.0);
> 
503a552,554
> 	gen->amplitude = 0;
> 	gen->phase = 0;
> 	gen->harmonic = 0;
528a580
> 	//fprintf(stdout, "CWRingRestart: cw_ring_reset = TRUE\n"), fflush(stdout);
634a687
> 	//fprintf(stdout, "SetKeyerResetSize: cw_ring_reset = TRUE\n"), fflush(stdout);
642,651c695,697
< 	if (HiPerformance)
< 	{
< 		key_poll_period = 1;
< 		TONE_SIZE = 48 * factor;
< 	}
< 	else
< 	{
< 		key_poll_period = 5;
< 		TONE_SIZE = 240 * factor;
< 	}
---
> 
> 	key_poll_period = 1;
> 	TONE_SIZE = 48 * factor;
diff ./keyer.c /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/keyer.c
79c79
< 	kl->timeout.dlay -= kl->timeout.dlay > 0 ? ticklen : 0;
---
> 	kl->timeout.dlay -= (kl->timeout.dlay > 0 ? ticklen : 0);
121,125c121,123
< 		if (((dit && dah) ||
< 			(kl->element.invtd &&
< 			kl->element.iamb != PADDLES_RELEASED) ||
< 			(kl->element.iamb == PADDLES_RELEASED &&
< 			iambicmode == MODE_B && (!midelementmodeB || kl->element.psqam))))
---
> 		if ((dit && dah) ||
> 			(kl->element.invtd && kl->element.iamb != PADDLES_RELEASED) ||
> 			(kl->element.iamb == PADDLES_RELEASED && iambicmode == MODE_B && (!midelementmodeB || kl->element.psqam)))
140c138
< 				kl->timeout.dlay = ditlen * 2;
---
> 				kl->timeout.dlay = ditlen * 2; 
150c148
< 	/* Is an element currently being played? */
---
> 	/* Is no element currently being played? */
diff ./keyerio.c /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/keyerio.c
108a109
> 		{
110a112
> 		}
114a117
> 		{
116a120
> 		}
Only in /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP: libfftw3f-3.lib
diff ./lmadf.c /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/lmadf.c
178c178
<   lms->signal = signal;
---
>   lms->signal = newCXB(signal->size,CXBbase(signal),"lmadf CXB");
181c181
<   lms->size = 512;
---
>   lms->size = 4096;
198a199
> 	  delCXB(lms->signal);
232,233c233,235
<       ssig_i (i) = error.im;
< 	  ssig (i) = error.re;
---
> 	  cssig(i) = error;
> //     ssig_i (i) = error.im;
> //	  ssig (i) = error.re;
Only in .: log
Only in .: Makefile
Only in .: Makefile.am
Only in .: Makefile.in
diff ./malloc16.h /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/malloc16.h
30c30
< //#include <malloc.h>
---
> #include <malloc.h>
Only in .: NEWS
diff ./ovsv.c /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/ovsv.c
136,139c136,139
<   zrvec = newvec_COMPLEX_fftw(fftlen, "raw signal vec in newFiltOvSv");
<   zfvec = newvec_COMPLEX_fftw(fftlen, "filter z vec in newFiltOvSv");
<   zivec = newvec_COMPLEX_fftw(fftlen, "signal in z vec in newFiltOvSv");
<   zovec = newvec_COMPLEX_fftw(fftlen, "signal out z vec in newFiltOvSv");
---
>   zrvec = newvec_COMPLEX_16(fftlen, "raw signal vec in newFiltOvSv");
>   zfvec = newvec_COMPLEX_16(fftlen, "filter z vec in newFiltOvSv");
>   zivec = newvec_COMPLEX_16(fftlen, "signal in z vec in newFiltOvSv");
>   zovec = newvec_COMPLEX_16(fftlen, "signal out z vec in newFiltOvSv");
196,199c196,199
<     delvec_COMPLEX_fftw(p->zfvec);
<     delvec_COMPLEX_fftw(p->zivec);
<     delvec_COMPLEX_fftw(p->zovec);
<     delvec_COMPLEX_fftw(p->zrvec);
---
>     delvec_COMPLEX_16(p->zfvec);
>     delvec_COMPLEX_16(p->zivec);
>     delvec_COMPLEX_16(p->zovec);
>     delvec_COMPLEX_16(p->zrvec);
Only in /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP: pthread.h
Only in /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP: pthreadVC.lib
Only in .: README
Only in /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP: resource.h
diff ./ringb.c /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/ringb.c
35,40c35,40
<   ringb_t *rb = (ringb_t *) safealloc (1, sizeof (ringb_t), "Ring creation");
<   rb->buf = safealloc (1, sz2, "Ring buffer buf");
<   rb->size = sz2;		// power-of-2-sized
<   rb->mask = rb->size - 1;
<   rb->wptr = rb->rptr = 0;
<   return rb;
---
> 	ringb_t *rb = (ringb_t *) safealloc (1, sizeof (ringb_t), "Ring creation");
> 	rb->buf = safealloc (1, sz2, "Ring buffer buf");
> 	rb->size = sz2;		// power-of-2-sized
> 	rb->mask = rb->size - 1;
> 	rb->wptr = rb->rptr = 0;
> 	return rb;
46,53c46,53
<   ringb_float_t *rb = (ringb_float_t *) safealloc (1, sizeof (ringb_float_t),
< 						   "Float Ring creation");
<   rb->buf =
<     (float *) safealloc (1, sz2 * sizeof (float), "Ring buffer float buf");
<   rb->size = sz2;		// power-of-2-sized
<   rb->mask = rb->size - 1;
<   rb->wptr = rb->rptr = 0;
<   return rb;
---
> 	ringb_float_t *rb = (ringb_float_t *) safealloc (1, sizeof (ringb_float_t),
> 		"Float Ring creation");
> 	rb->buf =
> 		(float *) safealloc (1, sz2 * sizeof (float), "Ring buffer float buf");
> 	rb->size = sz2;		// power-of-2-sized
> 	rb->mask = rb->size - 1;
> 	rb->wptr = rb->rptr = 0;
> 	return rb;
59,64c59,64
<   ringb_t *rb = (ringb_t *) usemem;
<   rb->buf = usemem + sizeof (ringb_t);
<   rb->size = sz2;		// power-of-2-sized
<   rb->mask = rb->size - 1;
<   rb->wptr = rb->rptr = 0;
<   return rb;
---
> 	ringb_t *rb = (ringb_t *) usemem;
> 	rb->buf = usemem + sizeof (ringb_t);
> 	rb->size = sz2;		// power-of-2-sized
> 	rb->mask = rb->size - 1;
> 	rb->wptr = rb->rptr = 0;
> 	return rb;
71,72c71,72
<   safefree (rb->buf);
<   safefree ((char *) rb);
---
> 	safefree (rb->buf);
> 	safefree ((char *) rb);
78,79c78,79
<   safefree ((void *) rb->buf);
<   safefree ((char *) rb);
---
> 	safefree ((void *) rb->buf);
> 	safefree ((char *) rb);
85,87c85,87
<   // NB not thread-safe
<   rb->rptr = 0;
<   rb->wptr = 0;
---
> 	// NB not thread-safe
> 	rb->rptr = 0;
> 	rb->wptr = 0;
93,95c93,95
<   // NB not thread-safe
<   rb->rptr = 0;
<   rb->wptr = 0;
---
> 	// NB not thread-safe
> 	rb->rptr = 0;
> 	rb->wptr = 0;
101,104c101,104
<   register size_t i;
<   char zero = 0;
<   for (i = 0; i < nbytes; i++)
<     ringb_write (rb, &zero, 1);
---
> 	register size_t i;
> 	char zero = 0;
> 	for (i = 0; i < nbytes; i++)
> 		ringb_write (rb, &zero, 1);
110,113c110,113
<   register size_t i;
<   float zero = 0;
<   for (i = 0; i < nfloats; i++)
<     ringb_float_write (rb, &zero, 1);
---
> 	register size_t i;
> 	float zero = 0.0f;
> 	for (i = 0; i < nfloats; i++)
> 		ringb_float_write (rb, &zero, 1);
119,120c119,120
<   ringb_reset (rb);
<   ringb_clear (rb, nbytes);
---
> 	ringb_reset (rb);
> 	ringb_clear (rb, nbytes);
126,127c126,127
<   ringb_float_reset (rb);
<   ringb_float_clear (rb, nfloats);
---
> 	ringb_float_reset (rb);
> 	ringb_float_clear (rb, nfloats);
133,137c133,137
<   size_t w = rb->wptr, r = rb->rptr;
<   if (w > r)
<     return w - r;
<   else
<     return (w - r + rb->size) & rb->mask;
---
> 	size_t w = rb->wptr, r = rb->rptr;
> 	if (w > r)
> 		return w - r;
> 	else
> 		return (rb->size + w - r ) & rb->mask;
143,147c143,147
<   size_t w = rb->wptr, r = rb->rptr;
<   if (w > r)
<     return w - r;
<   else
<     return (w - r + rb->size) & rb->mask;
---
> 	size_t w = rb->wptr, r = rb->rptr;
> 	if (w > r)
> 		return w - r;
> 	else
> 		return (rb->size + w - r ) & rb->mask;
153,159c153,159
<   size_t w = rb->wptr, r = rb->rptr;
<   if (w > r)
<     return ((r - w + rb->size) & rb->mask) - 1;
<   else if (w < r)
<     return r - w - 1;
<   else
<     return rb->size - 1;
---
> 	size_t w = rb->wptr, r = rb->rptr;
> 	if (w > r)
> 		return ((rb->size + r - w) & rb->mask) - 1;
> 	else if (w < r)
> 		return r - w - 1;
> 	else
> 		return rb->size - 1;
165,171c165,171
<   size_t w = rb->wptr, r = rb->rptr;
<   if (w > r)
<     return ((r - w + rb->size) & rb->mask) - 1;
<   else if (w < r)
<     return r - w - 1;
<   else
<     return rb->size - 1;
---
> 	size_t w = rb->wptr, r = rb->rptr;
> 	if (w > r)
> 		return ((rb->size + r - w) & rb->mask) - 1;
> 	else if (w < r)
> 		return r - w - 1;
> 	else
> 		return rb->size - 1;
177,192c177,192
<   size_t volatile free_cnt, cnt2, to_read, n1, n2;
<   if ((free_cnt = ringb_read_space (rb)) == 0)
<     return 0;
<   to_read = cnt > free_cnt ? free_cnt : cnt;
<   if ((cnt2 = rb->rptr + to_read) > rb->size)
<     n1 = rb->size - rb->rptr, n2 = cnt2 & rb->mask;
<   else
<     n1 = to_read, n2 = 0;
<   memcpy (dest, &(rb->buf[rb->rptr]), n1);
<   rb->rptr = (rb->rptr + n1) & rb->mask;
<   if (n2)
<     {
<       memcpy (dest + n1, &(rb->buf[rb->rptr]), n2);
<       rb->rptr = (rb->rptr + n2) & rb->mask;
<     }
<   return to_read;
---
> 	size_t volatile free_cnt, cnt2, to_read, n1, n2;
> 	if ((free_cnt = ringb_read_space (rb)) == 0)
> 		return 0;
> 	to_read = cnt > free_cnt ? free_cnt : cnt;
> 	if ((cnt2 = rb->rptr + to_read) > rb->size)
> 		n1 = rb->size - rb->rptr, n2 = cnt2 & rb->mask;
> 	else
> 		n1 = to_read, n2 = 0;
> 	memcpy (dest, &(rb->buf[rb->rptr]), n1);
> 	rb->rptr = (rb->rptr + n1) & rb->mask;
> 	if (n2)
> 	{
> 		memcpy (dest + n1, &(rb->buf[rb->rptr]), n2);
> 		rb->rptr = (rb->rptr + n2) & rb->mask;
> 	}
> 	return to_read;
198,213c198,213
<   size_t volatile free_cnt, cnt2, to_read, n1, n2;
<   if ((free_cnt = ringb_float_read_space (rb)) == 0)
<     return 0;
<   to_read = cnt > free_cnt ? free_cnt : cnt;
<   if ((cnt2 = rb->rptr + to_read) > rb->size)
<     n1 = rb->size - rb->rptr, n2 = cnt2 & rb->mask;
<   else
<     n1 = to_read, n2 = 0;
<   memcpy (dest, &(rb->buf[rb->rptr]), n1 * sizeof (float));
<   rb->rptr = (rb->rptr + n1) & rb->mask;
<   if (n2)
<     {
<       memcpy (dest + n1, &(rb->buf[rb->rptr]), n2 * sizeof (float));
<       rb->rptr = (rb->rptr + n2) & rb->mask;
<     }
<   return to_read;
---
> 	size_t volatile free_cnt, cnt2, to_read, n1, n2;
> 	if ((free_cnt = ringb_float_read_space (rb)) == 0)
> 		return 0;
> 	to_read = cnt > free_cnt ? free_cnt : cnt;
> 	if ((cnt2 = rb->rptr + to_read) > rb->size)
> 		n1 = rb->size - rb->rptr, n2 = cnt2 & rb->mask;
> 	else
> 		n1 = to_read, n2 = 0;
> 	memcpy (dest, &(rb->buf[rb->rptr]), n1 * sizeof (float));
> 	rb->rptr = (rb->rptr + n1) & rb->mask;
> 	if (n2)
> 	{
> 		memcpy (dest + n1, &(rb->buf[rb->rptr]), n2 * sizeof (float));
> 		rb->rptr = (rb->rptr + n2) & rb->mask;
> 	}
> 	return to_read;
219,232c219,232
<   size_t volatile free_cnt, cnt2, to_read, n1, n2, tmp_rptr;
<   tmp_rptr = rb->rptr;
<   if ((free_cnt = ringb_read_space (rb)) == 0)
<     return 0;
<   to_read = cnt > free_cnt ? free_cnt : cnt;
<   if ((cnt2 = tmp_rptr + to_read) > rb->size)
<     n1 = rb->size - tmp_rptr, n2 = cnt2 & rb->mask;
<   else
<     n1 = to_read, n2 = 0;
<   memcpy (dest, &(rb->buf[tmp_rptr]), n1);
<   tmp_rptr = (tmp_rptr + n1) & rb->mask;
<   if (n2)
<     memcpy (dest + n1, &(rb->buf[tmp_rptr]), n2);
<   return to_read;
---
> 	size_t volatile free_cnt, cnt2, to_read, n1, n2, tmp_rptr;
> 	tmp_rptr = rb->rptr;
> 	if ((free_cnt = ringb_read_space (rb)) == 0)
> 		return 0;
> 	to_read = cnt > free_cnt ? free_cnt : cnt;
> 	if ((cnt2 = tmp_rptr + to_read) > rb->size)
> 		n1 = rb->size - tmp_rptr, n2 = cnt2 & rb->mask;
> 	else
> 		n1 = to_read, n2 = 0;
> 	memcpy (dest, &(rb->buf[tmp_rptr]), n1);
> 	tmp_rptr = (tmp_rptr + n1) & rb->mask;
> 	if (n2)
> 		memcpy (dest + n1, &(rb->buf[tmp_rptr]), n2);
> 	return to_read;
238,253c238,253
<   size_t volatile free_cnt, cnt2, to_write, n1, n2;
<   if ((free_cnt = ringb_write_space (rb)) == 0)
<     return 0;
<   to_write = cnt > free_cnt ? free_cnt : cnt;
<   if ((cnt2 = rb->wptr + to_write) > rb->size)
<     n1 = rb->size - rb->wptr, n2 = cnt2 & rb->mask;
<   else
<     n1 = to_write, n2 = 0;
<   memcpy (&(rb->buf[rb->wptr]), src, n1);
<   rb->wptr = (rb->wptr + n1) & rb->mask;
<   if (n2)
<     {
<       memcpy (&(rb->buf[rb->wptr]), src + n1, n2);
<       rb->wptr = (rb->wptr + n2) & rb->mask;
<     }
<   return to_write;
---
> 	size_t volatile free_cnt, cnt2, to_write, n1, n2;
> 	if ((free_cnt = ringb_write_space (rb)) == 0)
> 		return 0;
> 	to_write = cnt > free_cnt ? free_cnt : cnt;
> 	if ((cnt2 = rb->wptr + to_write) > rb->size)
> 		n1 = rb->size - rb->wptr, n2 = cnt2 & rb->mask;
> 	else
> 		n1 = to_write, n2 = 0;
> 	memcpy (&(rb->buf[rb->wptr]), src, n1);
> 	rb->wptr = (rb->wptr + n1) & rb->mask;
> 	if (n2)
> 	{
> 		memcpy (&(rb->buf[rb->wptr]), src + n1, n2);
> 		rb->wptr = (rb->wptr + n2) & rb->mask;
> 	}
> 	return to_write;
259,274c259,274
<   size_t volatile free_cnt, cnt2, to_write, n1, n2;
<   if ((free_cnt = ringb_float_write_space (rb)) == 0)
<     return 0;
<   to_write = cnt > free_cnt ? free_cnt : cnt;
<   if ((cnt2 = rb->wptr + to_write) > rb->size)
<     n1 = rb->size - rb->wptr, n2 = cnt2 & rb->mask;
<   else
<     n1 = to_write, n2 = 0;
<   memcpy (&(rb->buf[rb->wptr]), src, n1 * sizeof (float));
<   rb->wptr = (rb->wptr + n1) & rb->mask;
<   if (n2)
<     {
<       memcpy (&(rb->buf[rb->wptr]), src + n1, n2 * sizeof (float));
<       rb->wptr = (rb->wptr + n2) & rb->mask;
<     }
<   return to_write;
---
> 	size_t volatile free_cnt, cnt2, to_write, n1, n2;
> 	if ((free_cnt = ringb_float_write_space (rb)) == 0)
> 		return 0;
> 	to_write = cnt > free_cnt ? free_cnt : cnt;
> 	if ((cnt2 = rb->wptr + to_write) > rb->size)
> 		n1 = rb->size - rb->wptr, n2 = cnt2 & rb->mask;
> 	else
> 		n1 = to_write, n2 = 0;
> 	memcpy (&(rb->buf[rb->wptr]), src, n1 * sizeof (float));
> 	rb->wptr = (rb->wptr + n1) & rb->mask;
> 	if (n2)
> 	{
> 		memcpy (&(rb->buf[rb->wptr]), src + n1, n2 * sizeof (float));
> 		rb->wptr = (rb->wptr + n2) & rb->mask;
> 	}
> 	return to_write;
280c280
<   rb->rptr = (rb->rptr + cnt) & rb->mask;
---
> 	rb->rptr = (rb->rptr + cnt) & rb->mask;
286c286
<   rb->wptr = (rb->wptr + cnt) & rb->mask;
---
> 	rb->wptr = (rb->wptr + cnt) & rb->mask;
292c292
<   rb->rptr = (rb->rptr + cnt) & rb->mask;
---
> 	rb->rptr = (rb->rptr + cnt) & rb->mask;
298c298
<   rb->wptr = (rb->wptr + cnt) & rb->mask;
---
> 	rb->wptr = (rb->wptr + cnt) & rb->mask;
304,318c304,318
<   size_t volatile free_cnt, cnt2, w = rb->wptr, r = rb->rptr;
<   if (w > r)
<     free_cnt = w - r;
<   else
<     free_cnt = (w - r + rb->size) & rb->mask;
<   if ((cnt2 = r + free_cnt) > rb->size)
<     {
<       vec[0].buf = &(rb->buf[r]), vec[0].len = rb->size - r;
<       vec[1].buf = rb->buf, vec[1].len = cnt2 & rb->mask;
<     }
<   else
<     {
<       vec[0].buf = &(rb->buf[r]), vec[0].len = free_cnt;
<       vec[1].len = 0;
<     }
---
> 	size_t volatile free_cnt, cnt2, w = rb->wptr, r = rb->rptr;
> 	if (w > r)
> 		free_cnt = w - r;
> 	else
> 		free_cnt = (w - r + rb->size) & rb->mask;
> 	if ((cnt2 = r + free_cnt) > rb->size)
> 	{
> 		vec[0].buf = &(rb->buf[r]), vec[0].len = rb->size - r;
> 		vec[1].buf = rb->buf, vec[1].len = cnt2 & rb->mask;
> 	}
> 	else
> 	{
> 		vec[0].buf = &(rb->buf[r]), vec[0].len = free_cnt;
> 		vec[1].len = 0;
> 	}
324,340c324,340
<   size_t volatile free_cnt, cnt2, w = rb->wptr, r = rb->rptr;
<   if (w > r)
<     free_cnt = ((r - w + rb->size) & rb->mask) - 1;
<   else if (w < r)
<     free_cnt = r - w - 1;
<   else
<     free_cnt = rb->size - 1;
<   if ((cnt2 = w + free_cnt) > rb->size)
<     {
<       vec[0].buf = &(rb->buf[w]), vec[0].len = rb->size - w;
<       vec[1].buf = rb->buf, vec[1].len = cnt2 & rb->mask;
<     }
<   else
<     {
<       vec[0].buf = &(rb->buf[w]), vec[0].len = free_cnt;
<       vec[1].len = 0;
<     }
---
> 	size_t volatile free_cnt, cnt2, w = rb->wptr, r = rb->rptr;
> 	if (w > r)
> 		free_cnt = ((r - w + rb->size) & rb->mask) - 1;
> 	else if (w < r)
> 		free_cnt = r - w - 1;
> 	else
> 		free_cnt = rb->size - 1;
> 	if ((cnt2 = w + free_cnt) > rb->size)
> 	{
> 		vec[0].buf = &(rb->buf[w]), vec[0].len = rb->size - w;
> 		vec[1].buf = rb->buf, vec[1].len = cnt2 & rb->mask;
> 	}
> 	else
> 	{
> 		vec[0].buf = &(rb->buf[w]), vec[0].len = free_cnt;
> 		vec[1].len = 0;
> 	}
Only in /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP: sched.h
diff ./sdr.c /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/sdr.c
132c132,139
< 	rx[thread][k].iqfix = newCorrectIQ (0.0, 1.0);
---
> 	if (thread == 0) {
> 		diversity.gain = 1.0;
> 		diversity.scalar = Cmplx(1.0,0);
> 	}
> 	rx[thread][k].iqfix = newCorrectIQ (0.0, 1.0, 0.000f);
> 	// Remove the next line
> 	rx[thread][k].iqfix->wbir_state = JustSayNo;
> 	// Remove the previous line
159a167,169
> 	rx[thread][k].dcb = newDCBlocker(DCB_SINGLE_POLE, rx[thread][k].buf.i);
> 	rx[thread][k].dcb->flag = FALSE;
> 
171,172c181,182
< 		CXBbase (rx[thread][k].buf.o),	// input buffer
< 		CXBsize (rx[thread][k].buf.o),	// output buffer
---
> 		CXBbase (rx[thread][k].buf.o),	// buffer pointer
> 		CXBsize (rx[thread][k].buf.o),	// buffer size
177c187
< 		250,							//Hangtime in ms
---
> 		250,							// Hangtime in ms
206,208c216,218
< 		-6000.0,						// REAL f_lobound
< 		6000.0,							// REAL f_hibound
< 		5000.0,							// REAL f_bandwid
---
> 		-8000.0,						// REAL f_lobound
> 		8000.0,							// REAL f_hibound
> 		16000.0,						// REAL f_bandwid
224,227c234,237
< 	rx[thread][k].banf.gen = new_blms(
< 		rx[thread][k].buf.o,    // CXB signal,
< 		0.01f,				// REAL adaptation_rate,
< 		0.00000f,				// REAL leakage,
---
> 	rx[thread][k].banf.gen = new_blms(
> 		rx[thread][k].buf.o,    // CXB signal,
> 		0.01f,				// REAL adaptation_rate,
> 		0.00000f,				// REAL leakage,
232,239d241
< 	rx[thread][k].banr.gen = new_blms(
< 		rx[thread][k].buf.o,    // CXB signal,
< 		0.001f,				// REAL adaptation_rate,
< 		0.000001f,				// REAL leakage,
< 		LMADF_NOISE,			// type
< 		uni->wisdom.bits);      // fftw wisdom
< 	rx[thread][k].banr.flag = FALSE;
< 
242,245c244,247
< 		64,						// int delay,
< 		0.01f,					// REAL adaptation_rate,
< 		0.0000001f,				// REAL leakage,
< 		45,						// int adaptive_filter_size,
---
> 		40,						// int delay,
> 		0.00015f,				// REAL adaptation_rate,
> 		0.000001f,				// REAL leakage,
> 		30,						// int adaptive_filter_size,
248a251,259
> 	rx[thread][k].banr.gen = new_blms(
> 		rx[thread][k].buf.o,    // CXB signal,
> 		0.001f,					// REAL adaptation_rate,
> 		0.000001f,				// REAL leakage,
> 		LMADF_NOISE,			// type
> 		uni->wisdom.bits);      // fftw wisdom
> 	rx[thread][k].banr.flag = FALSE;
> 
> 
292c303
< 	tx[thread].iqfix = newCorrectIQ (0.0, 1.0);
---
> 	tx[thread].iqfix = newCorrectIQ (0.0, 1.0, 0.0);
296a308,309
> 	tx[thread].filt.ovsv_pre = newFiltOvSv (FIRcoef (tx[thread].filt.coef),
> 		FIRsize (tx[thread].filt.coef), uni[thread].wisdom.bits);
309a323,326
> 	tx[thread].buf.ic = newCXB (FiltOvSv_fetchsize (tx[thread].filt.ovsv_pre),
> 		FiltOvSv_fetchpoint (tx[thread].filt.ovsv_pre), "init tx[thread].buf.ic");
> 	tx[thread].buf.oc = newCXB (FiltOvSv_storesize (tx[thread].filt.ovsv_pre),
> 		FiltOvSv_storepoint (tx[thread].filt.ovsv_pre), "init tx[thread].buf.oc");
323c340
< 	tx[thread].fm.cvtmod2freq = (REAL) (2500.0 * TWOPI / uni[thread].samplerate); //5 kHz deviation
---
> 	tx[thread].fm.cvtmod2freq = (REAL) (3000.0 * TWOPI / uni[thread].samplerate); //3 kHz deviation
335c352
< 		5.62f,						// Maximum gain as a multipler, linear not dB
---
> 		1.778f,						// Maximum gain as a multipler, linear not dB
345a363
> 	tx[thread].squelch.atten = 80.0;
355c373
< 		1.2f,							// Target output
---
> 		1.08f,							// Target output
359c377
< 		500,							//Hangtime in ms
---
> 		500,							// Hangtime in ms
567a586,587
> 			//fprintf(stdout, "rx gain: %15.12f\n", uni[thread].meter.rx.val[k][AGC_GAIN]);
> 			//fflush(stdout);
688a709,711
> 	int i, m = tx[thread].squelch.num, n = CXBhave (tx[thread].buf.i);
> 	int l = ((int)tx[thread].squelch.atten * m) / 100;
> 
691,693c714
< 		int i, m = tx[thread].squelch.num, n = CXBhave (tx[thread].buf.i) - m;
< 
< 		for (i = 0; i < m; i++)
---
> 		for (i = 0; i < n; i++)
694a716
> 			REAL scale = (REAL) (1.0 - (REAL) (i < l ? i : l) / m);
696c718
< 				Cscl (CXBdata (tx[thread].buf.i, i), (REAL) (1.0 - (REAL) i / m));
---
> 				Cscl (CXBdata (tx[thread].buf.i, i), scale);
698,699d719
< 
< 		memset ((void *) (CXBbase (tx[thread].buf.i) + m), 0, n * sizeof (COMPLEX));
701a722,730
> 	else if (l != m)
> 	{
> 		REAL scale = (REAL) (1.0 - (REAL) l / m);
> 		for (i = 0; i < n; i++)
> 		{
> 			CXBdata (tx[thread].buf.i, i) =
> 				Cscl (CXBdata (tx[thread].buf.i, i), scale);
> 		}
> 	}
724d752
< 
731a760,762
> 	int i, m = tx[thread].squelch.num, n = CXBhave (tx[thread].buf.i);
> 	int l = (((INT) tx[thread].squelch.atten) * m) / 100;
> 
734,735d764
< 		int i, m = tx[thread].squelch.num;
< 
737a767
> 			REAL scale = (REAL) (i < l ? l : i) / m;
739c769
< 				Cscl (CXBdata (tx[thread].buf.i, i), (REAL) i / m);
---
> 				Cscl (CXBdata (tx[thread].buf.i, i), scale);
741d770
< 
744a774
> /* Routine to do the actual adding of buffers through the complex linear combination required */
745a776,786
> #if 0
> void
> do_rx_diversity_combine()
> {
> 	int i, n=CXBhave (rx[0][0].buf.i);
> 	for (i=0;i<n;i++)
> 	{
> 		CXBdata(rx[0][0].buf.i,i) = Cscl(Cadd(CXBdata(rx[0][0].buf.i,i),Cmul(CXBdata(rx[2][0].buf.i,i),diversity.scalar)),diversity.gain);
> 	}
> }
> #endif
751a793,797
> 	// metering for uncorrected values here
> 	do_rx_meter (k, thread, rx[thread][k].buf.i, RXMETER_PRE_CONV);	
> 
> 	if (rx[thread][k].dcb->flag) DCBlock(rx[thread][k].dcb);
> 
755,758c801
< 		SDROMnoiseblanker (rx[thread][k].nb_sdrom.gen);
< 
< 	// metering for uncorrected values here
< 	do_rx_meter (k, thread, rx[thread][k].buf.i, RXMETER_PRE_CONV);
---
> 		SDROMnoiseblanker (rx[thread][k].nb_sdrom.gen);			
760c803
< 	correctIQ (rx[thread][k].buf.i, rx[thread][k].iqfix);
---
> 	correctIQ (rx[thread][k].buf.i, rx[thread][k].iqfix, FALSE, k);
836,837c879,893
< 		lmsr_adapt (rx[thread][k].anf.gen);
< 		//blms_adapt(rx[thread][k].banf.gen);
---
> 	{
> 		switch(rx[thread][k].mode)
> 		{
> 			case DRM:
> 			case DIGL:
> 			case DIGU:
> 			case CWL:
> 			case CWU: // do nothing
> 				break;
> 			default:
> 				lmsr_adapt (rx[thread][k].anf.gen);
> 				//blms_adapt(rx[thread][k].banf.gen);
> 				break;
> 		}
> 	}
843,846c899,912
< 	DttSPAgc (rx[thread][k].dttspagc.gen, rx[thread][k].tick);
< 
< 
< 
---
> 	/*if(thread == 0 && k == 0)
> 		fprintf(stdout, "before: %15f12  ", CXBpeak(rx[thread][k].buf.i));*/
> #if 0
> 	if (diversity.flag && (k==0) && (thread==2))
> 		for (i = 0; i < n; i++) CXBdata(rx[thread][k].buf.o,i) = cxzero;
> 	else 
> #endif
> 		DttSPAgc (rx[thread][k].dttspagc.gen, rx[thread][k].tick);
> 	
> 	/*if(thread == 0 && k == 0)
> 	{
> 		fprintf(stdout, "after: %15f12\n", CXBpeak(rx[thread][k].buf.o));
> 		fflush(stdout);
> 	}*/
848c914
< 	do_rx_meter(k, thread, rx[thread][k].buf.o,RXMETER_POST_AGC);
---
> 	do_rx_meter(k, thread, rx[thread][k].buf.o, RXMETER_POST_AGC);
868,869c934,938
< 	if (rx[thread][k].output_gain != 1.0)
< 		for (i = 0; i < n; i++) CXBdata(rx[thread][k].buf.o,i) = Cscl(CXBdata(rx[thread][k].buf.o,i),rx[thread][k].output_gain);
---
> 	if ((thread == 2)  && (diversity.flag))
> 		for (i=0;i< n; i++) CXBdata(rx[thread][k].buf.o,i) = cxzero;
> 	else
> 		if (rx[thread][k].output_gain != 1.0)
> 			for (i = 0; i < n; i++) CXBdata(rx[thread][k].buf.o,i) = Cscl(CXBdata(rx[thread][k].buf.o,i),rx[thread][k].output_gain);
889,890d957
< 	if (rx[thread][k].anf.flag)
< 		lmsr_adapt (rx[thread][k].anf.gen);
999a1067,1068
> 			//fprintf(stdout, "pk: %15.12f  comp: %15.12f\n", uni[thread].meter.tx.val[TX_ALC_PK], uni[thread].meter.tx.val[TX_ALC_G]);
> 			//fflush(stdout);
1075a1145,1147
> 
> 			if (tx[thread].alc.flag)
> 				DttSPAgc (tx[thread].alc.gen, tx[thread].tick);
1076a1149
> 
1089a1163,1167
> 			if (tx[thread].alc.flag)
> 				DttSPAgc (tx[thread].alc.gen, tx[thread].tick);
> 			do_tx_meter (thread, tx[thread].buf.i, TX_ALC);
> 			//fprintf(stderr,"[%.2f,%.2f]  ", peakl(tx[thread].buf.i), peakr(tx[thread].buf.i));
> 
1100,1103d1177
< 			if (tx[thread].alc.flag)
< 				DttSPAgc (tx[thread].alc.gen, tx[thread].tick);
< 			do_tx_meter (thread, tx[thread].buf.i, TX_ALC);
< 			//fprintf(stderr,"[%.2f,%.2f]  ", peakl(tx[thread].buf.i), peakr(tx[thread].buf.i));
1108,1112d1181
< // KD5TFD added - experimental support for EER mode transmit, and Mercury transmit
< extern int EerXmit;
< #define SQRT2 (1.414213562f)
< extern int MercuryXmit;
< 
1127,1155d1195
< 	// kd5tfd added eer support
< 	// for envelope elimination restoration xmit we want amgnitude in I and phase in q
< 	if ( EerXmit  )
< 	{
< 		int i, n;
< 		switch ( tx[thread].mode )
< 		{
< 			case USB:
< 			case LSB:
< 			case CWU:
< 			case CWL:
< 			case DIGU:
< 			case DIGL:
< 			case DSB:	            	
< 				n = CXBhave(tx[thread].buf.o);
< 				for ( i = 0; i < n; i++ ) 
< 				{
< 					COMPLEX z = Cr2p(CXBdata(tx[thread].buf.o, i));
< 					// mag in real, angle in im
< 					z.re = z.re / SQRT2;   // normalize -  +1 is max value allowable
< 					z.im = z.im  / (REAL)PI;     // normalize - want angle to range -/+ 1;
< 					CXBdata(tx[thread].buf.o, i) = z;
< 				}
< 				break;
< 			default:
< 				break;
< 		}
< 	}
< 
1158c1198
< 	if (tx[thread].osc.gen->Frequency != 0.0 && MercuryXmit == 0 )
---
> 	if (tx[thread].osc.gen->Frequency != 0.0)
1168c1208
< 	correctIQ (tx[thread].buf.o, tx[thread].iqfix);
---
> 	correctIQ (tx[thread].buf.o, tx[thread].iqfix, TRUE,0);
diff ./sdrexport.c /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/sdrexport.c
36,39c36,39
< struct _uni uni[MAX_THREADS];
< struct _rx rx[MAX_THREADS][MAXRX];
< struct _tx tx[MAX_THREADS];
< struct _top top[MAX_THREADS];
---
> struct _uni uni[3];
> struct _rx rx[3][MAXRX];
> struct _tx tx[3];
> struct _top top[3];
diff ./sdrexport.h /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/sdrexport.h
1,171c1,175
< /* sdrexport.h
< 
< This file is part of a program that implements a Software-Defined Radio.
< 
< Copyright (C) 2004, 2005, 2006 by Frank Brickle, AB2KT and Bob McGwier, N4HY
< 
< This program is free software; you can redistribute it and/or modify
< it under the terms of the GNU General Public License as published by
< the Free Software Foundation; either version 2 of the License, or
< (at your option) any later version.
< 
< This program is distributed in the hope that it will be useful,
< but WITHOUT ANY WARRANTY; without even the implied warranty of
< MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
< GNU General Public License for more details.
< 
< You should have received a copy of the GNU General Public License
< along with this program; if not, write to the Free Software
< Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
< 
< The authors can be reached by email at
< 
< ab2kt@arrl.net
< or
< rwmcgwier@comcast.net
< 
< or by paper mail at
< 
< The DTTS Microwave Society
< 6 Kathleen Place
< Bridgewater, NJ 08807
< */
< 
< #ifndef _sdrexport_h
< #define _sdrexport_h
< 
< #include <fromsys.h>
< #include <defs.h>
< #include <banal.h>
< #include <splitfields.h>
< #include <datatypes.h>
< #include <bufvec.h>
< #include <cxops.h>
< #include <ringb.h>
< #include <lmadf.h>
< #include <fftw3.h>
< #include <fftw3_fix.h>
< #include <ovsv.h>
< #include <filter.h>
< #include <oscillator.h>
< #include <dttspagc.h>
< #include <am_demod.h>
< #include <fm_demod.h>
< #include <noiseblanker.h>
< #include <correctIQ.h>
< #include <speechproc.h>
< #include <spottone.h>
< #include <hilbert.h>
< #include <update.h>
< #include <local.h>
< #include <meter.h>
< #include <spectrum.h>
< //------------------------------------------------------------------------
< // max no receiver and transmitter threads
< #ifndef MAX_THREADS
< #define MAX_THREADS (2)
< #endif
< //------------------------------------------------------------------------
< // max no. simultaneous receivers (main and sub)
< #ifndef MAXRX
< #define MAXRX (2)
< #endif
< //------------------------------------------------------------------------
< /* modulation types, modes */
< 
< //========================================================================
< /* RX/TX both */
< //------------------------------------------------------------------------
< extern struct _uni
< {
<   REAL samplerate;
<   int buflen;
< 
<   struct
<   {
<     SDRMODE sdr;
<     TRXMODE trx;
<   } mode;
< 
<   METERBlock meter;
<   SpecBlock spec;
< 
<   struct
<   {
<     BOOLEAN flag;
<     FILE *fp;
<     splitfld splt;
<   } update;
< 
<   struct
<   {
<     char *path;
<     int bits;
<   } wisdom;
< 
<   struct
<   {
<     BOOLEAN act[MAXRX];
<     int lis, nac, nrx;
<   } multirx;
< 
<   struct
<   {
<     struct
<     {
<       BOOLEAN flag;
<       REAL gain;
<     } rx, tx;
<   } mix;
<   int cpdlen;
<   long tick,oldtick;
< 
< } uni[MAX_THREADS];
< 
< //------------------------------------------------------------------------
< /* RX */
< //------------------------------------------------------------------------
< 
< extern struct _rx
< {
<   struct
<   {
<     CXB i, o;
<   } buf;
<   IQ iqfix;
<   struct
<   {
<     double freq, phase;
<     OSC gen;
<   } osc;
<   struct
<   {
< 	 int decim;
< 	 BOOLEAN flag;
< 	 ResStF gen1r,gen1i,gen2r,gen2i;
<   } resample;
<   float output_gain;
<   struct
<   {
<     ComplexFIR coef;
<     FiltOvSv ovsv;
<     COMPLEX *save;
<   } filt;
<   struct
<   {
<     REAL thresh;
<     NB gen;
<     BOOLEAN flag;
<   } nb;
<   struct
<   {
<     REAL thresh;
<     NB gen;
<     BOOLEAN flag;
<   } nb_sdrom;
<   struct
<   {
<     LMSR gen;
<     BOOLEAN flag;
<   } anr, anf;
< 
---
> /* sdrexport.h
> 
> This file is part of a program that implements a Software-Defined Radio.
> 
> Copyright (C) 2004, 2005, 2006 by Frank Brickle, AB2KT and Bob McGwier, N4HY
> 
> This program is free software; you can redistribute it and/or modify
> it under the terms of the GNU General Public License as published by
> the Free Software Foundation; either version 2 of the License, or
> (at your option) any later version.
> 
> This program is distributed in the hope that it will be useful,
> but WITHOUT ANY WARRANTY; without even the implied warranty of
> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> GNU General Public License for more details.
> 
> You should have received a copy of the GNU General Public License
> along with this program; if not, write to the Free Software
> Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
> 
> The authors can be reached by email at
> 
> ab2kt@arrl.net
> or
> rwmcgwier@comcast.net
> 
> or by paper mail at
> 
> The DTTS Microwave Society
> 6 Kathleen Place
> Bridgewater, NJ 08807
> */
> 
> #ifndef _sdrexport_h
> #define _sdrexport_h
> 
> #include <fromsys.h>
> #include <defs.h>
> #include <banal.h>
> #include <splitfields.h>
> #include <datatypes.h>
> #include <bufvec.h>
> #include <cxops.h>
> #include <ringb.h>
> #include <lmadf.h>
> #include <fftw3.h>
> #include <fftw3_fix.h>
> #include <ovsv.h>
> #include <filter.h>
> #include <oscillator.h>
> #include <dttspagc.h>
> #include <am_demod.h>
> #include <fm_demod.h>
> #include <noiseblanker.h>
> #include <correctIQ.h>
> #include <speechproc.h>
> #include <spottone.h>
> #include <hilbert.h>
> #include <update.h>
> #include <local.h>
> #include <meter.h>
> #include <spectrum.h>
> #include <diversity.h>
> 
> //------------------------------------------------------------------------
> // max no. simultaneous receivers
> #ifndef MAXRX
> #define MAXRX (4)
> #endif
> //------------------------------------------------------------------------
> /* modulation types, modes */
> 
> //========================================================================
> /* RX/TX both */
> //------------------------------------------------------------------------
> 
> DiversityControl diversity;
> 
> extern struct _uni
> {
>   REAL samplerate;
>   int buflen;
> 
>   struct
>   {
>     SDRMODE sdr;
>     TRXMODE trx;
>   } mode;
> 
>   METERBlock meter;
>   SpecBlock spec;
> 
>   struct
>   {
>     BOOLEAN flag;
>     FILE *fp;
>     splitfld splt;
>   } update;
> 
>   struct
>   {
>     char *path;
>     int bits;
>   } wisdom;
> 
>   struct
>   {
>     BOOLEAN act[MAXRX];
>     int lis, nac, nrx;
>   } multirx;
> 
>   struct
>   {
>     struct
>     {
>       BOOLEAN flag;
>       REAL gain;
>     } rx, tx;
>   } mix;
>   int cpdlen;
>   long tick,oldtick;
>   WBIR_STATE wbir_state;
> } uni[3];
> 
> //------------------------------------------------------------------------
> /* RX */
> //------------------------------------------------------------------------
> 
> extern struct _rx
> {
>   struct
>   {
>     CXB i, o;
>   } buf;
>   IQ iqfix;
>   struct
>   {
>     double freq, phase;
>     OSC gen;
>   } osc;
>   struct
>   {
> 	 int decim;
> 	 BOOLEAN flag;
> 	 ResStF gen1r,gen1i,gen2r,gen2i;
>   } resample;
>   float output_gain;
>   struct
>   {
>     ComplexFIR coef;
>     FiltOvSv ovsv;
>     COMPLEX *save;
>   } filt,filt2;
> 
>   DCBlocker dcb;
> 
>   struct
>   {
>     REAL thresh;
>     NB gen;
>     BOOLEAN flag;
>   } nb;
>   struct
>   {
>     REAL thresh;
>     NB gen;
>     BOOLEAN flag;
>   } nb_sdrom;
> 
>   struct
>   {
>     LMSR gen;
>     BOOLEAN flag;
>   } anr, anf;
> 
176,429c180,433
<   } banr, banf;
< 
<   struct
<   {
<     DTTSPAGC gen;
<     BOOLEAN flag;
<   } dttspagc;
<   struct
<   {
<     AMD gen;
<   } am;
<   struct
<   {
<     FMD gen;
<   } fm;
<   struct
<   {
<     BOOLEAN flag;
<     SpotToneGen gen;
<   } spot;
<   struct
<   {
<     REAL thresh, power;
<     BOOLEAN flag, running, set;
<     int num;
<   } squelch;
< 
<   struct
<   {
<     BOOLEAN flag;
<     WSCompander gen;
<   } cpd;
< 
<   struct
<   {
<     EQ gen;
<     BOOLEAN flag;
<   } grapheq;
< 
<   SDRMODE mode;
<   struct
<   {
<     BOOLEAN flag;
<   } bin;
<   REAL norm;
<   COMPLEX azim;
<   long tick;
< } rx[MAX_THREADS][MAXRX];
< 
< //------------------------------------------------------------------------
< /* TX */
< //------------------------------------------------------------------------
< extern struct _tx
< {
<   struct
<   {
<     CXB i, o;
<   } buf;
<   IQ iqfix;
< 
<   struct
<   {
<     BOOLEAN flag;
<     DCBlocker gen;
<   } dcb;
< 
<   struct
<   {
<     double freq, phase;
<     OSC gen;
<   } osc;
<   struct
<   {
<     ComplexFIR coef;
<     FiltOvSv ovsv;
<     COMPLEX *save;
<   } filt;
< 
<   struct
<   {
<     REAL carrier_level;
<   } am;
< 
<   struct
<   {
<     REAL cvtmod2freq;
<   } fm;
< 
<   struct
<   {
<     REAL thresh, power;
<     BOOLEAN flag, running, set;
<     int num;
<   } squelch;
< 
<   struct
<   {
<     DTTSPAGC gen;
<     BOOLEAN flag;
<   } leveler, alc;
< 
<   struct
<   {
<     EQ gen;
<     BOOLEAN flag;
<   } grapheq;
< 
< 
<   struct
<   {
<     SpeechProc gen;
<     BOOLEAN flag;
<   } spr;
< 
< 
<   struct
<   {
<     BOOLEAN flag;
<     WSCompander gen;
<   } cpd;
< 
<   struct
<   {
< 	  BOOLEAN flag;
< 	  Hilsim gen;
<   } hlb;
< 
<   SDRMODE mode;
< 
<   long tick;
<   REAL norm;
< } tx[MAX_THREADS];
< 
< //------------------------------------------------------------------------
< 
< typedef enum _runmode
< {
<   RUN_MUTE, RUN_PASS, RUN_PLAY, RUN_SWCH
< } RUNMODE;
< 
< extern struct _top
< {
<   //DWORD pid;
<   int pid;
<   uid_t uid;
< 
<   struct timeval start_tv;
< 
<   BOOLEAN running, verbose;
<   RUNMODE state;
< 
<   // audio io
<   struct
<   {
<     struct
<     {
<       float *l, *r;
<     } aux, buf;
<     struct
<     {
<       unsigned int frames, bytes;
<     } size;
<   } hold;
< 
<   struct
<   {
<     char *path;
<     HANDLE fd;
<     HANDLE fp;
<     char buff[4096];
<   } parm;
< 
<   struct
<   {
<     struct
<     {
<       char *path;
<       HANDLE fp, fd;
<     } mtr, spec;
<   } meas;
< 
<   struct
<   {
<     char name[256];
< 
<     struct
<     {
<       struct
<       {
< 	ringb_float_t *l, *r;
<       } i, o;
<     } ring;
< 
<     struct
<     {
<       struct
<       {
< 	ringb_float_t *l, *r;
<       } i, o;
<     } auxr;
< 
< 
<     size_t reset_size;
< 
<     size_t size;
< 
<     struct
<     {
<       int cb;
<       struct
<       {
< 	int i, o;
<       } rb;
<       int xr;
<     } blow;
<   } jack;
< 
<   // update io
<   // multiprocessing & synchronization
<   struct
<   {
<     struct
<     {
<       pthread_t id;
<     } trx, upd, updrx, mon, pws, mtr, scope;
<   } thrd;
< 
<   struct
<   {
<     struct
<     {
<       sem_t sem;
<     } buf, upd, mon, pws, mtr, scope;
<   } sync;
< 
<   // TRX switching
< #if 0
<   struct
<   {
<     struct
<     {
<       int want, have;
<     } bfct;
<     struct
<     {
<       TRXMODE next;
<     } trx;
<     struct
<     {
<       RUNMODE last;
<     } run;
<     int fade, tail;
<   } swch;
< #endif
---
>   } banr, banf;
> 
>   struct
>   {
>     DTTSPAGC gen;
>     BOOLEAN flag;
>   } dttspagc;
>   struct
>   {
>     AMD gen;
>   } am;
>   struct
>   {
>     FMD gen;
>   } fm;
>   struct
>   {
>     BOOLEAN flag;
>     SpotToneGen gen;
>   } spot;
>   struct
>   {
>     REAL thresh, atten, power;
>     BOOLEAN flag, running, set;
>     int num;
> 	int phase;
>   } squelch;
> 
>   struct
>   {
>     BOOLEAN flag;
>     WSCompander gen;
>   } cpd;
> 
>   struct
>   {
>     EQ gen;
>     BOOLEAN flag;
>   } grapheq;
> 
>   SDRMODE mode;
>   struct
>   {
>     BOOLEAN flag;
>   } bin;
>   REAL norm;
>   COMPLEX azim;
>   long tick;
> } rx[3][MAXRX];
> 
> //------------------------------------------------------------------------
> /* TX */
> //------------------------------------------------------------------------
> extern struct _tx
> {
>   struct
>   {
>     CXB i, ic, o, oc;
>   } buf;
>   IQ iqfix;
> 
>   struct
>   {
>     BOOLEAN flag;
>     DCBlocker gen;
>   } dcb;
> 
>   struct
>   {
>     double freq, phase;
>     OSC gen;
>   } osc;
>   struct
>   {
>     ComplexFIR coef;
>     FiltOvSv ovsv, ovsv_pre;
>     COMPLEX *save;
>   } filt;
> 
>   struct
>   {
>     REAL carrier_level;
>   } am;
> 
>   struct
>   {
>     REAL cvtmod2freq;
>   } fm;
> 
>   struct
>   {
>     REAL thresh, atten, power;
>     BOOLEAN flag, running, set;
>     int num;
>   } squelch;
> 
>   struct
>   {
>     DTTSPAGC gen;
>     BOOLEAN flag;
>   } leveler, alc;
> 
>   struct
>   {
>     EQ gen;
>     BOOLEAN flag;
>   } grapheq;
> 
> 
>   struct
>   {
>     SpeechProc gen;
>     BOOLEAN flag;
>   } spr;
> 
> 
>   struct
>   {
>     BOOLEAN flag;
>     WSCompander gen;
>   } cpd;
> 
>   struct
>   {
> 	  BOOLEAN flag;
> 	  Hilsim gen;
>   } hlb;
> 
>   SDRMODE mode;
> 
>   long tick;
>   REAL norm;
> } tx[3];
> 
> //------------------------------------------------------------------------
> 
> typedef enum _runmode
> {
>   RUN_MUTE, RUN_PASS, RUN_PLAY, RUN_SWCH
> } RUNMODE;
> 
> extern struct _top
> {
>   DWORD pid;
>   uid_t uid;
> 
>   struct timeval start_tv;
> 
>   BOOLEAN running, verbose;
>   RUNMODE state;
> 
>   // audio io
>   struct
>   {
>     struct
>     {
>       float *l, *r;
>     } aux, buf;
>     struct
>     {
>       unsigned int frames, bytes;
>     } size;
>   } hold;
> 
>   struct
>   {
>     char *path;
>     HANDLE fd;
>     HANDLE fp;
>     char buff[4096];
>   } parm;
> 
>   struct
>   {
>     struct
>     {
>       char *path;
>       HANDLE fp, fd;
>     } mtr, spec;
>   } meas;
> 
>   struct
>   {
>     char name[256];
> 
>     struct
>     {
>       struct
>       {
> 	ringb_float_t *l, *r;
>       } i, o;
>     } ring;
> 
>     struct
>     {
>       struct
>       {
> 	ringb_float_t *l, *r;
>       } i, o;
>     } auxr;
> 
> 
>     size_t reset_size;
> 
>     size_t size;
> 
>     struct
>     {
>       int cb;
>       struct
>       {
> 	int i, o;
>       } rb;
>       int xr;
>     } blow;
>   } jack;
> 
>   // update io
>   // multiprocessing & synchronization
>   struct
>   {
>     struct
>     {
>       pthread_t id;
>     } trx, upd, updrx, mon, pws, mtr, scope;
>   } thrd;
> 
>   struct
>   {
>     struct
>     {
>       sem_t sem;
>     } buf, upd, mon, pws, mtr, scope;
>   } sync;
> 
>   // TRX switching
> #if 0
>   struct
>   {
>     struct
>     {
>       int want, have;
>     } bfct;
>     struct
>     {
>       TRXMODE next;
>     } trx;
>     struct
>     {
>       RUNMODE last;
>     } run;
>     int fade, tail;
>   } swch;
> #endif
453,460c457,464
<   
<   BOOLEAN susp;
<   int offset;
< 
< } top[MAX_THREADS];
< 
< 
< #endif
---
>   
>   BOOLEAN susp;
>   int offset;
> 
> } top[3];
> 
> 
> #endif
Only in /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP: semaphore.h
diff ./spectrum.c /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/spectrum.c
154c154
< 	p = newvec_COMPLEX_fftw(sb->size*16,"spectrum accum");
---
> 	p = newvec_COMPLEX_16(sb->size*16,"spectrum accum");
156c156
< 	p = newvec_COMPLEX_fftw(sb->size, "spectrum timebuf");
---
> 	p = newvec_COMPLEX_16(sb->size, "spectrum timebuf");
158c158
< 	p = newvec_COMPLEX_fftw(sb->size, "spectrum timebuf");
---
> 	p = newvec_COMPLEX_16(sb->size, "spectrum timebuf");
191c191
< 		delvec_COMPLEX_fftw(sb->accum->data);
---
> 		delvec_COMPLEX_16(sb->accum->data);
193c193
< 		delvec_COMPLEX_fftw(sb->timebuf->data);
---
> 		delvec_COMPLEX_16(sb->timebuf->data);
195c195
< 		delvec_COMPLEX_fftw(sb->freqbuf->data);
---
> 		delvec_COMPLEX_16(sb->freqbuf->data);
Only in .: .svn
diff ./update.c /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/update.c
40c40
< unsigned int threadno=MAXRX;
---
> unsigned int threadno=2;
60c60
< Setup_SDR ()
---
> Setup_SDR (char *app_data_path)
62c62
< 	extern void setup ();
---
> 	extern void setup (app_data_path);
111c111,112
< 		for(k=0; k<2; k++) {
---
> 		for(k=0; k<2; k++)
> 		{
138a140
> 	//fprintf(stdout,"AudioReset: reset_em = TRUE\n"), fflush(stdout);
143c145,162
< SetDCBlock (unsigned int thread, BOOLEAN setit)
---
> SetRXDCBlock(unsigned int thread, unsigned int subrx, BOOLEAN setit)
> {
> 	//fprintf(stderr, "DttSP: DCBlock(%u, %u)=%u\n", thread, subrx, setit), fflush(stderr);
> 	sem_wait(&top[thread].sync.upd.sem);
> 	rx[thread][subrx].dcb->flag = setit;
> 	sem_post(&top[thread].sync.upd.sem);
> }
> 
> DttSP_EXP void
> SetRXDCBlockGain(unsigned int thread, unsigned int subrx, REAL gain)
> {
> 	sem_wait(&top[thread].sync.upd.sem);
> 	rx[thread][subrx].dcb->gain = gain;
> 	sem_post(&top[thread].sync.upd.sem);
> }
> 
> DttSP_EXP void
> SetTXDCBlock (unsigned int thread, BOOLEAN setit)
149a169,177
> DttSP_EXP void
> SetTXFMDeviation(unsigned int thread, double deviation)
> {
> 	sem_wait(&top[thread].sync.upd.sem);
> 	tx[thread].fm.cvtmod2freq = (REAL) (deviation * TWOPI / uni[thread].samplerate);
> 	sem_post(&top[thread].sync.upd.sem);
> 
> }
> 
264a293
> 
279a309
> 
338a369
> 	if (!setit) memset(rx[thread][subrx].anr.gen->adaptive_filter,0,sizeof(COMPLEX)*128);
342,343d372
< 
< 
345c374
< SetNRvals (unsigned int thread, unsigned subrx, int taps, int delay, double gain, double leak)
---
> SetNRvals (unsigned int thread, unsigned subrx, int taps, int delay, double gain, double leakage)
348d376
< 	//fprintf(stderr, "SetNRvals(%u, %u, %u, %u, %lf, %lf)\n", thread, subrx, taps, delay, gain, leak); fflush(stderr);
351d378
< 	//fprintf(stderr,"thread:%0d subrx:%0d gain = %f\n",thread,subrx,rx[thread][subrx].banr.gen->adaptation_rate),fflush(stderr);
354c381,382
< 	rx[thread][subrx].anr.gen->leakage = (REAL)leak;
---
> 	rx[thread][subrx].anr.gen->leakage = (REAL)leakage;
> 	memset(rx[thread][subrx].anr.gen->adaptive_filter,0,sizeof(COMPLEX)*128);
390a419,426
> SetTXSquelchAtt (unsigned int thread, float setit)
> {
> 	sem_wait(&top[thread].sync.upd.sem);
> 	tx[thread].squelch.atten = setit;
> 	sem_post(&top[thread].sync.upd.sem);
> }
> 
> DttSP_EXP void
394a431
> 	if (!setit) memset(rx[thread][subrx].anf.gen->adaptive_filter,0,sizeof(COMPLEX)*128);
408a446
> 	memset(rx[thread][subrx].anf.gen->adaptive_filter,0,sizeof(COMPLEX)*128);
473,475c511,513
< 	rx[thread][subrx].dttspagc.gen->hangindex = rx[thread][subrx].dttspagc.gen->indx = 0;
< 	rx[thread][subrx].dttspagc.gen->fastindx = (int)(0.003f*uni[thread].samplerate);
< 	rx[thread][subrx].dttspagc.gen->sndx = (int) (uni[thread].samplerate * 0.003f);
---
> 	rx[thread][subrx].dttspagc.gen->hangindex = rx[thread][subrx].dttspagc.gen->slowindx = 0;
> 	rx[thread][subrx].dttspagc.gen->fastindx = (int)(0.0027f*uni[thread].samplerate);
> 	rx[thread][subrx].dttspagc.gen->out_indx = (int)(0.003f*uni[thread].samplerate);
533,534c571,572
< 		rx[thread][subrx].dttspagc.gen->indx = 0;
< 	rx[thread][subrx].dttspagc.gen->fastindx = (int)(0.003*uni[thread].samplerate);
---
> 		rx[thread][subrx].dttspagc.gen->slowindx = 0;
> 	rx[thread][subrx].dttspagc.gen->fastindx = (int)(0.0027*uni[thread].samplerate);
539c577
< 	rx[thread][subrx].dttspagc.gen->sndx = (int) (uni[thread].samplerate * tmp * 0.003f);
---
> 	rx[thread][subrx].dttspagc.gen->out_indx = (int) (uni[thread].samplerate * tmp * 0.003f);
565a604
> 
587a627
> 
598a639,646
> 	tx[thread].alc.gen->slowindx = 0;
> 	tx[thread].alc.gen->out_indx = (int) (0.003 * uni[thread].samplerate * tmp);
> 	tx[thread].alc.gen->fastindx = (int) (0.0027 * uni[thread].samplerate * tmp);
> 
> 
> /*
> 	tx[thread].alc.gen->attack = (REAL) (1.0 - exp (-1000.0 / (tmp * uni[thread].samplerate)));
> 	tx[thread].alc.gen->one_m_attack = (REAL) exp (-1000.0 / (tmp * uni[thread].samplerate));
603a652
> 		*/
649a699
> 
663d712
< 
669c718,725
< 	tx[thread].leveler.gen->attack =
---
> 
> 	tx[thread].leveler.gen->attack = (REAL) (1.0 - exp (-1000.0 / (tmp * uni[thread].samplerate)));
> 	tx[thread].leveler.gen->one_m_attack = (REAL) exp (-1000.0 / (tmp * uni[thread].samplerate));
> 	tx[thread].leveler.gen->slowindx = 0;
> 	tx[thread].leveler.gen->out_indx = (int) (0.003 * uni[thread].samplerate * tmp);
> 	tx[thread].leveler.gen->fastindx = (int) (0.0027 * uni[thread].samplerate * tmp);
> 
> /*	tx[thread].leveler.gen->attack =
678,679c734,735
< 		FASTLEAD * tx[thread].leveler.gen->mask) & tx[thread].leveler.gen->mask;
< 	tx[thread].leveler.gen->fasthangtime = (REAL) 0.01f;      //n4hy 10 ms
---
> 		FASTLEAD * tx[thread].leveler.gen->mask) & tx[thread].leveler.gen->mask; */
> 	tx[thread].leveler.gen->fasthangtime = (REAL) 0.01;      //n4hy 10 ms
724c780,781
< 	rx[thread][subrx].dttspagc.gen->gain.top = dB2lin((REAL)max_agc);
---
> 	rx[thread][subrx].dttspagc.gen->gain.top = 
> 		max(rx[thread][subrx].dttspagc.gen->gain.bottom,dB2lin((REAL)max_agc));
764a822,829
> SetCorrectIQGain (unsigned int thread, unsigned int subrx, double gain)
> {
> 	sem_wait(&top[thread].sync.upd.sem);
> 	rx[thread][subrx].iqfix->gain = (REAL) (1.0 + 0.001 * gain);
> 	sem_post(&top[thread].sync.upd.sem);
> }
> 
> DttSP_EXP void
773c838,849
< SetCorrectIQGain (unsigned int thread, unsigned int subrx, double gain)
---
> SetCorrectIQEnable(int setit)
> {
> 	extern int IQdoit;
> 	sem_wait(&top[0].sync.upd.sem);
> 
> 	IQdoit = setit;
> 	//fprintf(stderr,"setit = %d\n",setit),fflush(stderr);
> 	sem_post(&top[0].sync.upd.sem);
> }
> 
> DttSP_EXP void
> SetCorrectRXIQMu (unsigned int thread, unsigned int subrx, double mu)
776c852,903
< 	rx[thread][subrx].iqfix->gain = (REAL) (1.0 + 0.001 * gain);
---
> 	rx[thread][subrx].iqfix->mu = (REAL)mu;
> 	//memset((void *)rx[thread][subrx].iqfix->w,0,16*sizeof(COMPLEX));
> 	//memset((void *)rx[thread][subrx].iqfix->del,0,16*sizeof(COMPLEX));
> 	//memset((void *)rx[thread][subrx].iqfix->y,0,16*sizeof(COMPLEX));
> 	sem_post(&top[thread].sync.upd.sem);
> }
> 
> DttSP_EXP void
> SetCorrectWBIRState(unsigned int thread,WBIR_STATE wbir)
> {
> 	sem_wait(&top[thread].sync.upd.sem);
> 	uni[thread].wbir_state = wbir;
> 	sem_post(&top[thread].sync.upd.sem);
> }
> 
> DttSP_EXP REAL
> GetCorrectRXIQMu(unsigned int thread, unsigned int subrx)
> {
> 	return rx[thread][subrx].iqfix->mu;
> }
> 
> DttSP_EXP void
> SetCorrectRXIQw (unsigned int thread, unsigned int subrx, REAL wr, REAL wi, unsigned int index)
> {
> 	sem_wait(&top[thread].sync.upd.sem);
> 	rx[thread][subrx].iqfix->w[index] = Cmplx((REAL)wr,(REAL)wi);
> 	if (index == 0) memset((void *)&rx[thread][subrx].iqfix->w[1],0,15*sizeof(COMPLEX));
> 	sem_post(&top[thread].sync.upd.sem);
> }
> 
> DttSP_EXP void
> GetCorrectRXIQw(int thread, int subrx, REAL *realw, REAL *imagw, unsigned int index)
> {
> 	sem_wait(&top[thread].sync.upd.sem);
> 	*realw = rx[thread][subrx].iqfix->w[index].re;
> 	*imagw = rx[thread][subrx].iqfix->w[index].im;
> 	sem_post(&top[thread].sync.upd.sem);
> }
> 
> DttSP_EXP void
> SetCorrectRXIQwReal (unsigned int thread, unsigned int subrx, REAL wr, unsigned int index)
> {
> 	sem_wait(&top[thread].sync.upd.sem);
> 	rx[thread][subrx].iqfix->w[index].re = (REAL)wr;
> 	sem_post(&top[thread].sync.upd.sem);
> }
> 
> DttSP_EXP void
> SetCorrectRXIQwImag (unsigned int thread, unsigned int subrx, REAL wi, unsigned int index)
> {
> 	sem_wait(&top[thread].sync.upd.sem);
> 	rx[thread][subrx].iqfix->w[index].im = (REAL)wi;
789a917,924
> SetCorrectTXIQGain (unsigned int thread, double gain)
> {
> 	sem_wait(&top[thread].sync.upd.sem);
> 	tx[thread].iqfix->gain = (REAL) (1.0 + 0.001 * gain);
> 	sem_post(&top[thread].sync.upd.sem);
> }
> 
> DttSP_EXP void
798c933
< SetCorrectTXIQGain (unsigned int thread, double gain)
---
> SetCorrectTXIQMu (unsigned int thread, double mu)
801c936
< 	tx[thread].iqfix->gain = (REAL) (1.0 + 0.001 * gain);
---
> 	tx[thread].iqfix->mu = (REAL)mu;
804a940,946
> DttSP_EXP void
> SetCorrectTXIQW (unsigned int thread, double wr, double wi)
> {
> 	sem_wait(&top[thread].sync.upd.sem);
> 	tx[thread].iqfix->w[0] = Cmplx((REAL)wr,(REAL)wi);
> 	sem_post(&top[thread].sync.upd.sem);
> }
1134d1275
< 
1173c1314
< 	//int i;
---
> //	int i;
1175d1315
< 
1176a1317
> 
1185a1327
> 
1189a1332,1362
> FlushAllBufs (unsigned int thread, BOOLEAN trx)
> {
> 	int i;
> 	sem_wait (&top[thread].sync.upd.sem);
> 
> 	if(trx)
> 	{
> 		reset_OvSv(tx[thread].filt.ovsv);
> 		memset(top[thread].hold.buf.l,0,top[thread].hold.size.frames*sizeof(REAL));
> 		memset(top[thread].hold.buf.r,0,top[thread].hold.size.frames*sizeof(REAL));
> 		DttSPAgc_flushbuf(tx[thread].leveler.gen);
> 		DttSPAgc_flushbuf(tx[thread].alc.gen);
> 	}
> 	else
> 	{
> 		//fprintf(stdout, "FlushAllBufs(%u, %u)\n", thread, trx), fflush(stdout);
> 		memset(top[thread].hold.buf.l,0,top[thread].hold.size.frames*sizeof(REAL));
> 		memset(top[thread].hold.buf.r,0,top[thread].hold.size.frames*sizeof(REAL));
> 		for(i=0; i<uni[thread].multirx.nrx; i++)
> 		{
> 			reset_OvSv(rx[thread][i].filt.ovsv);
> 			DttSPAgc_flushbuf(rx[thread][i].dttspagc.gen);
> 		}
> 	}
> 
> 	sem_post (&top[thread].sync.upd.sem);
> 
> 	//fprintf(stdout, "DttSP: FlushAllBufs\n"), fflush(stdout);
> }
> 
> DttSP_EXP void
1196a1370
> 	//fprintf(stdout,"SetDSPBuflen: reset_em = TRUE\n"), fflush(stdout);
1339a1514
> 	//fprintf(stdout,"SetRingBufferOffset: reset_em = TRUE\n"), fflush(stdout);
1436,1437d1610
< 
< 
1562,1566c1735,1736
< 
< // kd5tfd added - experimental support for MercuryXmit and EerXmit
< int MercuryXmit = 0;
< 
< DttSP_EXP void SetMercuryXmit(int on_off) 
---
> DttSP_EXP void
> SetDiversity (int setit)
1568c1738,1747
<     MercuryXmit = on_off;
---
> 	extern BOOLEAN reset_em;
> 	//fprintf(stderr, "SetDiversity: %u\n", setit), fflush(stderr);
> 	sem_wait(&top[0].sync.upd.sem);
> 	sem_wait(&top[1].sync.upd.sem);
> 	sem_wait(&top[2].sync.upd.sem);
> //	reset_em=TRUE;
> 	diversity.flag = setit;
> 	sem_post(&top[0].sync.upd.sem);
> 	sem_post(&top[1].sync.upd.sem);
> 	sem_post(&top[2].sync.upd.sem);
1571c1750,1757
< int EerXmit = 0;
---
> DttSP_EXP void
> SetDiversityScalar(REAL re, REAL im)
> {
> 	//fprintf(stderr, "SetDiversityScalar: %f, %f\n", re, im), fflush(stderr);
> 	sem_wait(&top[2].sync.upd.sem);
> 	diversity.scalar = Cmplx(re,im);
> 	sem_post(&top[2].sync.upd.sem);
> }
1573c1759,1760
< DttSP_EXP void SetEerXmit(int on_off)
---
> DttSP_EXP void
> SetDiversityGain(REAL gain)
1575c1762,1765
<     EerXmit = on_off;
---
> 	//fprintf(stderr, "SetDiversityGain: %f\n", gain), fflush(stderr);
> 	sem_wait(&top[2].sync.upd.sem);
> 	diversity.gain = gain;
> 	sem_post(&top[2].sync.upd.sem);
1576a1767
> 
diff ./winmain.c /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/winmain.c
1,666c1,876
< /* winmain.c
< 
< This file is part of a program that implements a Software-Defined Radio.
< 
< Copyright (C) 2004, 2005, 2006, 2007 by Frank Brickle, AB2KT and Bob McGwier, N4HY
< 
< This program is free software; you can redistribute it and/or modify
< it under the terms of the GNU General Public License as published by
< the Free Software Foundation; either version 2 of the License, or
< (at your option) any later version.
< 
< This program is distributed in the hope that it will be useful,
< but WITHOUT ANY WARRANTY; without even the implied warranty of
< MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
< GNU General Public License for more details.
< 
< You should have received a copy of the GNU General Public License
< along with this program; if not, write to the Free Software
< Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
< 
< The authors can be reached by email at
< 
< ab2kt@arrl.net
< or
< rwmcgwier@comcast.net
< 
< or by paper mail at
< 
< The DTTS Microwave Society
< 6 Kathleen Place
< Bridgewater, NJ 08807
< */
< 
< #include <common.h>
< /////////////////////////////////////////////////////////////////////////
< 
< // elementary defaults
< struct _loc loc[3];
< extern unsigned int threadno;
< /////////////////////////////////////////////////////////////////////////
< // most of what little we know here about the inner loop,
< // functionally speaking
< 
< extern void reset_meters (unsigned int);
< extern void reset_spectrum (unsigned int);
< extern void reset_counters (unsigned int);
< extern void process_samples (float *, float *, float *, float *, int, unsigned int);
< extern void setup_workspace (REAL rate,
< 			     int buflen,
< 			     SDRMODE mode,
< 			     char *wisdom,
< 			     int specsize, int numrecv, int cpdsize, unsigned int thread);
< extern void destroy_workspace (unsigned int thread);
< 
< 
< //========================================================================
< 
< //========================================================================
< 
< 
< 
< BOOLEAN reset_em;
< 
< PRIVATE BOOLEAN
< gethold (unsigned int proc_thread)
< {
< 	if (ringb_float_read_space (top[proc_thread].jack.ring.i.l) >= top[proc_thread].hold.size.frames)
< 		{
< 			ringb_float_read (top[proc_thread].jack.ring.i.l,
< 				top[proc_thread].hold.buf.l, top[proc_thread].hold.size.frames);
< 			ringb_float_read (top[proc_thread].jack.ring.i.r,
< 				top[proc_thread].hold.buf.r, top[proc_thread].hold.size.frames);
< 	#ifdef USE_AUXILIARY
< 			ringb_float_read (top[proc_thread].jack.auxr.i.l,
< 				top[proc_thread].hold.aux.l, top[proc_thread].hold.size.frames);
< 			ringb_float_read (top[thread].jack.auxr.i.r,
< 				top[proc_thread].hold.aux.r, top[proc_thread].hold.size.frames);
< 	#else
< 			ringb_float_read (top[proc_thread].jack.auxr.i.l,
< 				top[proc_thread].hold.buf.l, top[proc_thread].hold.size.frames);
< 			ringb_float_read (top[proc_thread].jack.auxr.i.r,
< 				top[proc_thread].hold.buf.r, top[proc_thread].hold.size.frames);
< 	#endif
< 			return TRUE;
< 		} else return FALSE;
< 
< }
< PRIVATE void
< puthold(unsigned int proc_thread)
< {
< 	   if (ringb_float_write_space (top[proc_thread].jack.ring.o.l) >= top[proc_thread].hold.size.frames)
< 		{
< 			ringb_float_write (top[proc_thread].jack.ring.o.l, top[proc_thread].hold.buf.l,
< 				top[proc_thread].hold.size.frames);
< 			ringb_float_write (top[proc_thread].jack.ring.o.r, top[proc_thread].hold.buf.r,
< 				top[proc_thread].hold.size.frames);
< 	#ifdef USE_AUXILIARY
< 			ringb_float_write (top[proc_thread].jack.auxr.o.l, top[proc_thread].hold.aux.l,
< 				top[proc_thread].hold.size.frames);
< 			ringb_float_write (top[proc_thread].jack.auxr.o.r, top[proc_thread].hold.aux.r,
< 				top[proc_thread].hold.size.frames);
< 	#else
< 			ringb_float_write (top[proc_thread].jack.auxr.o.l, top[proc_thread].hold.buf.l,
< 				top[proc_thread].hold.size.frames);
< 			ringb_float_write (top[proc_thread].jack.auxr.o.r, top[proc_thread].hold.buf.r,
< 				top[proc_thread].hold.size.frames);
< 		}
< 	#endif
< 
< }
< PRIVATE BOOLEAN
< canhold (unsigned int proc_thread)
< {
< 
< 	return (ringb_float_read_space (top[proc_thread].jack.ring.i.l) >=
< 		(size_t) top[proc_thread].hold.size.frames);
< }
< 
< 
< //------------------------------------------------------------------------
< 
< PRIVATE void
< run_mute (unsigned int thread)
< {
< 	memset ((char *) top[thread].hold.buf.l, 0, top[thread].hold.size.bytes);
< 	memset ((char *) top[thread].hold.buf.r, 0, top[thread].hold.size.bytes);
< 	memset ((char *) top[thread].hold.aux.l, 0, top[thread].hold.size.bytes);
< 	memset ((char *) top[thread].hold.aux.r, 0, top[thread].hold.size.bytes);
< 	uni[thread].tick++;
< }
< 
< PRIVATE void
< run_pass (unsigned int thread)
< {
< 	uni[thread].tick++;
< }
< 
< PRIVATE void
< run_play (unsigned int thread)
< {
< 	process_samples (top[thread].hold.buf.l, top[thread].hold.buf.r,
< 		top[thread].hold.aux.l, top[thread].hold.aux.r, top[thread].hold.size.frames, thread);
< }
< 
< // NB do not set RUN_SWCH directly via setRunState;
< // use setSWCH instead
< 
< 
< PRIVATE void
< run_swch(unsigned int thread)
< {
< 	int i, n = top[thread].hold.size.frames;
< 	REAL w;
< //	static int count = 0;
< 
< 	process_samples(top[thread].hold.buf.l, top[thread].hold.buf.r,
< 		top[thread].hold.aux.l, top[thread].hold.aux.r,
< 		top[thread].hold.size.frames, thread);
< 
< 	for (i = 0; i < n; i++)
< 	{
< //		count++;
< 		if (top[thread].swch.env.curr.type == SWCH_FALL)
< 		{
< 			top[thread].swch.env.curr.val += top[thread].swch.env.fall.incr;
< 			w = (REAL)sin(top[thread].swch.env.curr.val * M_PI /  2.0f);
< 			top[thread].hold.buf.l[thread] *= w, top[thread].hold.buf.r[thread] *= w;
< 			top[thread].hold.aux.l[thread] *= w, top[thread].hold.aux.r[thread] *= w;
< //			if (top[thread].swch.env.curr.cnt == 0) fprintf(stderr, "FALL\n"),fflush(stderr);
< //			if(top[thread].swch.env.curr.cnt == 0) top[thread].hold.buf.l[thread] = top[thread].hold.buf.r[thread] = -1.0;
< 			if (++top[thread].swch.env.curr.cnt >= top[thread].swch.env.fall.size)
< 			{
< 				//top[thread].hold.buf.l[thread] = top[thread].hold.buf.r[thread] = -1.0;
< 				top[thread].swch.env.curr.type = SWCH_STDY;
< 				top[thread].swch.env.curr.cnt = 0;
< 				top[thread].swch.env.curr.val = 0.0;
< //				fprintf(stderr, "Fall End: %d\n", count);
< 			}
< 		}
< 		else if (top[thread].swch.env.curr.type == SWCH_STDY)
< 		{
< 			top[thread].hold.buf.l[i]= top[thread].hold.buf.r[i] =
< 				top[thread].hold.aux.l[i] =  top[thread].hold.aux.r[i] = 0.0;
< //			if (top[thread].swch.env.curr.cnt == 0) fprintf(stderr, "STDY\n"),fflush(stderr);
< 			if (++top[thread].swch.env.curr.cnt >= top[thread].swch.env.stdy.size)
< 			{
< //				top[thread].hold.buf.l[thread] = top[thread].hold.buf.r[thread] = -1.0;
< 				top[thread].swch.env.curr.type = SWCH_RISE;
< 				top[thread].swch.env.curr.cnt = 0;
< 				top[thread].swch.env.curr.val = 0.0;
< //				fprintf(stderr, "Stdy End: %d\n", count);
< 			}
< 		}
< 		else if (top[thread].swch.env.curr.type == SWCH_RISE)
< 		{
< 			top[thread].swch.env.curr.val += top[thread].swch.env.rise.incr;
< 			w = (REAL)sin(top[thread].swch.env.curr.val * M_PI /  2.0f);
< 			top[thread].hold.buf.l[i] *= w, top[thread].hold.buf.r[i] *= w;
< 			top[thread].hold.aux.l[i] *= w, top[thread].hold.aux.r[i] *= w;
< //			if (top[thread].swch.env.curr.cnt == 0) fprintf(stderr, "RISE\n"),fflush(stderr);
< 			if (++top[thread].swch.env.curr.cnt >= top[thread].swch.env.rise.size)
< 			{
< //				reset_meters();
< //				reset_spectrum();
< //				reset_counters();
< 	
< 				uni[thread].mode.trx = top[thread].swch.trx.next;
< 				top[thread].state = top[thread].swch.run.last;
< 				break;
< //				fprintf(stderr, "Rise End: %d\n", count);
< 			}
< 		}
< 	}
< }
< 
< 
< //========================================================================
< 
< static void reset_system_audio(size_t nframes)
< {
< 	size_t reset_size;
< 	unsigned int thread;
< 	const float zero = 0.;
< 	int i;
< 
< 	reset_em = FALSE;
< 	for(thread = 0; thread < threadno; thread++) {
< 		reset_size = max (top[thread].jack.reset_size, nframes);
< 		ringb_float_reset (top[thread].jack.ring.i.l);
< 		ringb_float_reset (top[thread].jack.ring.i.r);
< 		ringb_float_reset (top[thread].jack.auxr.i.l);
< 		ringb_float_reset (top[thread].jack.auxr.i.r);
< 	
< 		if (top[thread].offset < 0)
< 		{
< 			for(i=top[thread].offset;i<0;i++)
< 			{
< 				ringb_float_write(top[thread].jack.ring.i.l,&zero,1);
< 				ringb_float_write(top[thread].jack.auxr.i.l,&zero,1);
< 			}
< 		}
< 		else
< 		{
< 			for(i=0;i<top[thread].offset;i++)
< 			{
< 				ringb_float_write(top[thread].jack.ring.i.r,&zero,1);
< 				ringb_float_write(top[thread].jack.auxr.i.r,&zero,1);
< 			}
< 		}
< 
< 		ringb_float_restart (top[thread].jack.ring.o.r, reset_size);
< 		ringb_float_restart (top[thread].jack.ring.o.l, reset_size);
< 		ringb_float_restart (top[thread].jack.auxr.o.r, reset_size);
< 		ringb_float_restart (top[thread].jack.auxr.o.l, reset_size);
< 	}
< }
< 
< DttSP_EXP void
< Audio_Callback (float *input_l, float *input_r, float *output_l,
< 	float *output_r, unsigned int nframes, int thread)
< {
< 	BOOLEAN b = reset_em;
< 	int i;
< 
<         i=thread;
< 
< 	if (top[i].susp)
< 	{
< 		memset (output_l, 0, nframes * sizeof (float));
< 		memset (output_r, 0, nframes * sizeof (float));
< //fprintf(stderr,"Audio_Callback: top[%d].susp!!! Ouput flushed!\n",i);
< 		return;
< 	}
< 
< 	if (b)
< 	{
< 		reset_system_audio(nframes);
< 		memset (output_l, 0, nframes * sizeof (float));
< 		memset (output_r, 0, nframes * sizeof (float));
< //fprintf(stderr,"Audio_Callback: reset_em!!! Ouput flushed!\n");
< 		return;
<         }
< 
< 	//for (i=0;i<1;i++) {
< 		if ((ringb_float_read_space (top[i].jack.ring.o.l) >= nframes)
< 			&& (ringb_float_read_space (top[i].jack.ring.o.r) >= nframes))
< 		{
< 			if (top[i].state == RUN_PLAY) {
< //fprintf(stderr,"copying to ouput (thread=%d) (RUN_PLAY)\n",i);
< 				ringb_float_read (top[i].jack.auxr.o.l, output_l, nframes);
< 				ringb_float_read (top[i].jack.auxr.o.r, output_r, nframes);
< 				ringb_float_read (top[i].jack.ring.o.l, output_l, nframes);
< 				ringb_float_read (top[i].jack.ring.o.r, output_r, nframes);
< 			} else {
< //fprintf(stderr,"copying to ouput (thread=%d) (NOT RUN_PLAY)\n",i);
< 				ringb_float_read_advance (top[i].jack.auxr.o.l, nframes);
< 				ringb_float_read_advance (top[i].jack.auxr.o.r, nframes);
< 				ringb_float_read_advance (top[i].jack.ring.o.l, nframes);
< 				ringb_float_read_advance (top[i].jack.ring.o.r, nframes);
< 
< 			}
< 		}
< 		else
< 		{	// rb pathology
< //fprintf(stderr,"rb pathology1: (rx=%d)reset_em=TRUE!!!! (%d,%d)\n",i,ringb_float_read_space (top[i].jack.ring.o.l),top[i].hold.size.frames);
< //			reset_em=TRUE;
< //			memset (output_l, 0, nframes * sizeof (float));
< //			memset (output_r, 0, nframes * sizeof (float));
< 		}
< 
< 		// input: copy from port to ring
< 		if ((ringb_float_write_space (top[i].jack.ring.i.l) >= nframes)
< 			&& (ringb_float_write_space (top[i].jack.ring.i.r) >= nframes))
< 		{
< 			ringb_float_write (top[i].jack.ring.i.l, (float *) input_l, nframes);
< 			ringb_float_write (top[i].jack.ring.i.r, (float *) input_r, nframes);
< 			ringb_float_write (top[i].jack.auxr.i.l, (float *) input_l, nframes);
< 			ringb_float_write (top[i].jack.auxr.i.r, (float *) input_r, nframes);
< 		}
< 		else
< 		{	// rb pathology
< //fprintf(stderr,"rb pathology2: reset_em=TRUE!!!! Ouput flushed!\n");
< //			reset_em=TRUE;
< //			memset (output_l, 0, nframes * sizeof (float));
< //			memset (output_r, 0, nframes * sizeof (float));
< 		}
< 
< 		// if enough accumulated in ring, fire dsp
< 		if (ringb_float_read_space (top[i].jack.ring.i.l) >= top[i].hold.size.frames)
<                 {
< //fprintf(stderr,"fire dsp thread=%d\n",thread);
< 			sem_post (&top[i].sync.buf.sem);
<                 }
< 	//}
< }
< 
< DttSP_EXP void
< Audio_Callback2 (float **input, float **output, unsigned int nframes)
< {
< 	unsigned int thread;
< 	BOOLEAN b = reset_em=FALSE;
< 	BOOLEAN return_empty=FALSE;
< 	for(thread=0;thread<threadno;thread++) {
< 		if (top[thread].susp) return_empty = TRUE;
< 	}
< 	if (return_empty)
< 	{
< 			for(thread=0;thread<threadno;thread++)  {
< 				memset (output[2*thread], 0, nframes * sizeof (float));
< 				memset (output[2*thread+1], 0, nframes * sizeof (float));
< 			}
< 			return;
< 	}
< 	if (b)
< 	{
< 		reset_system_audio(nframes);
< 		for(thread=0;thread<threadno;thread++) {
< 			memset (output[2*thread], 0, nframes * sizeof (float));
< 			memset (output[2*thread+1], 0, nframes * sizeof (float));
< 		}
< 		return;
<     }
< 	for(thread=0;thread<threadno;thread++) {
< 		int l=2*thread,r = 2*thread+1;
< 		if ((ringb_float_read_space (top[thread].jack.ring.o.l) >= nframes)
< 			&& (ringb_float_read_space (top[thread].jack.ring.o.r) >= nframes))
< 		{
< 			ringb_float_read (top[thread].jack.auxr.o.l, output[l], nframes);
< 			ringb_float_read (top[thread].jack.auxr.o.r, output[r], nframes);
< 			ringb_float_read (top[thread].jack.ring.o.l, output[l], nframes);
< 			ringb_float_read (top[thread].jack.ring.o.r, output[r], nframes);
< 		}
< 		else
< 		{	// rb pathology
< 			reset_em=TRUE;//reset_system_audio(nframes);
< 			memset (output[2*thread  ], 0, nframes * sizeof (float));
< 			memset (output[2*thread+1], 0, nframes * sizeof (float));
< 		}
< 
< 		// input: copy from port to ring
< 		if ((ringb_float_write_space (top[thread].jack.ring.i.l) >= nframes)
< 			&& (ringb_float_write_space (top[thread].jack.ring.i.r) >= nframes))
< 		{
< 			ringb_float_write (top[thread].jack.ring.i.l, input[l], nframes);
< 			ringb_float_write (top[thread].jack.ring.i.r, input[r], nframes);
< 			ringb_float_write (top[thread].jack.auxr.i.l, input[l], nframes);
< 			ringb_float_write (top[thread].jack.auxr.i.r, input[r], nframes);
< 		}
< 		else
< 		{	// rb pathology
< 			reset_em=TRUE;
< 			memset (output[2*thread  ], 0, nframes * sizeof (float));
< 			memset (output[2*thread+1], 0, nframes * sizeof (float));
< 		}
< 			// if enough accumulated in ring, fire dsp
< 		sem_post (&top[thread].sync.buf.sem);
< 
< 	}
< 
< }
< 
< 
< //========================================================================
< 
< 
< DttSP_EXP void
< process_samples_thread (unsigned int proc_thread)
< {
< 	while (top[proc_thread].running)
< 	{
< 		sem_wait (&top[proc_thread].sync.buf.sem);
< 		while (gethold(proc_thread)) {
< 			sem_wait (&top[proc_thread].sync.upd.sem);
< 			switch (top[proc_thread].state)
< 			{
< 				case RUN_MUTE:
< 					run_mute (proc_thread);
< 					break;
< 				case RUN_PASS:
< 					run_pass (proc_thread);
< 					break;
< 				case RUN_PLAY:
< 					run_play (proc_thread);
< 					break;
< 				case RUN_SWCH:
< 					run_swch (proc_thread);
< 					break;
< 			}
< 			sem_post (&top[proc_thread].sync.upd.sem);
< 			puthold (proc_thread);
< 		}
< 	}
< }
< 
< 
< 
< void
< closeup ()
< {
< 	unsigned int thread;
< 	for(thread = 0; thread<MAX_THREADS;thread++) {
< 		top[thread].running = FALSE;
< 		top[thread].susp = TRUE;
< 		//Sleep (96);
< 		ringb_float_free (top[thread].jack.auxr.i.l);
< 		ringb_float_free (top[thread].jack.auxr.i.r);
< 		ringb_float_free (top[thread].jack.auxr.o.l);
< 		ringb_float_free (top[thread].jack.auxr.o.r);
< 
< 		ringb_float_free (top[thread].jack.ring.o.r);
< 		ringb_float_free (top[thread].jack.ring.o.l);
< 		ringb_float_free (top[thread].jack.ring.i.r);
< 		ringb_float_free (top[thread].jack.ring.i.l);
< 
< 		destroy_workspace (thread);
< 	}
< 	//Sleep(100);
< 	//fprintf(stderr,"Done with destructor\n"),fflush(stderr);
< }
< 
< 
< 
< PRIVATE void
< setup_local_audio (unsigned int thread)
< {
< 	top[thread].hold.size.frames = uni[thread].buflen;
< 	top[thread].hold.size.bytes = top[thread].hold.size.frames * sizeof (float);
< 	top[thread].hold.buf.l =
< 		(float *) safealloc (top[thread].hold.size.frames, sizeof (float),
< 		"main hold buffer left");
< 	top[thread].hold.buf.r =
< 		(float *) safealloc (top[thread].hold.size.frames, sizeof (float),
< 		"main hold buffer right");
< 	top[thread].hold.aux.l =
< 		(float *) safealloc (top[thread].hold.size.frames, sizeof (float),
< 		"aux hold buffer left");
< 	top[thread].hold.aux.r =
< 		(float *) safealloc (top[thread].hold.size.frames, sizeof (float),
< 			"aux hold buffer right");
< }
< 
< 
< PRIVATE void
< setup_system_audio (unsigned int thread)
< {
< 
< 	sprintf (top[thread].jack.name, "sdr-%d-%0u", top[thread].pid,thread);
< 
< fprintf(stderr,"setup_system_audio: %s\n",top[thread].jack.name);
< 	top[thread].jack.size = 1024;
< 
< 	memset ((char *) &top[thread].jack.blow, 0, sizeof (top[thread].jack.blow));
< 	top[thread].jack.ring.i.l = ringb_float_create (top[thread].jack.size * loc[thread].mult.ring);
< 	top[thread].jack.ring.i.r = ringb_float_create (top[thread].jack.size * loc[thread].mult.ring);
< 	top[thread].jack.ring.o.l = ringb_float_create (top[thread].jack.size * loc[thread].mult.ring);
< 	top[thread].jack.ring.o.r = ringb_float_create (top[thread].jack.size * loc[thread].mult.ring);
< 	top[thread].jack.auxr.i.l = ringb_float_create (top[thread].jack.size * loc[thread].mult.ring);
< 	top[thread].jack.auxr.i.r = ringb_float_create (top[thread].jack.size * loc[thread].mult.ring);
< 	top[thread].jack.auxr.o.l = ringb_float_create (top[thread].jack.size * loc[thread].mult.ring);
< 	top[thread].jack.auxr.o.r = ringb_float_create (top[thread].jack.size * loc[thread].mult.ring);
< 	ringb_float_clear (top[thread].jack.ring.o.l, top[thread].hold.size.frames);
< 	ringb_float_clear (top[thread].jack.ring.o.r, top[thread].hold.size.frames);
< }
< 
< PRIVATE void
< setup_threading (unsigned int thread)
< {
< 
< 		top[thread].susp = FALSE;
< 		sem_init (&top[thread].sync.upd.sem, 0, 0);
< 		sem_init (&top[thread].sync.buf.sem, 0, 0);	
<                 pthread_create(&top[thread].pid, 0, (void *) process_samples_thread, thread);
< 
< }
< 
< //========================================================================
< // hard defaults, then environment
< 
< PRIVATE void
< setup_defaults (unsigned int thread)
< {
<   //fprintf(stderr,"I am inside setup defaults thread: %0u\n",thread),fflush(stderr);
<   loc[thread].name[0] = 0;		// no default name for jack client
<   sprintf (loc[thread].path.rcfile, "%s%0lu_%0u", RCBASE, top[thread].pid,thread);
<   sprintf (loc[thread].path.parm, "%s%0lu_%0u", PARMPATH, top[thread].pid,thread);
<   sprintf (loc[thread].path.meter, "%s%0lu_%0u", METERPATH, top[thread].pid,thread);
<   sprintf (loc[thread].path.spec, "%s%0lu_%0u", SPECPATH, top[thread].pid,thread);
<   sprintf (loc[thread].path.wisdom, "%s%0lu_%0u", WISDOMPATH, top[thread].pid,thread);
<   loc[thread].def.rate = DEFRATE;
<   loc[thread].def.size = DEFSIZE;
<   loc[thread].def.nrx = MAXRX;
<   loc[thread].def.mode = DEFMODE;
<   loc[thread].def.spec = DEFSPEC;
<   loc[thread].mult.ring = RINGMULT;
<   loc[thread].def.comp = DEFCOMP;
< }
< 
< //========================================================================
< void
< setup ()
< {
< 	unsigned int thread;
< 	//fprintf(stderr,"I am inside setup\n"),fflush(stderr);
< 	for (thread=0;thread<MAX_THREADS;thread++) {
< 		top[thread].pid = getpid(); //GetCurrentThreadId ();
< 		top[thread].uid = 0L;
< 		top[thread].start_tv = now_tv ();
< 		top[thread].running = TRUE;
< 		top[thread].verbose = FALSE;
< 		if (thread != 1) top[thread].state = RUN_PLAY;
< 		else top[thread].state = RUN_PASS;
< 		top[thread].offset = 0;
< 		top[thread].jack.reset_size = 1024;
< 		reset_em =TRUE;
< 		setup_defaults (thread);
< 		
< 		//fprintf(stderr,"setup: defaults done thread %u\n", thread),fflush(stderr);
< 		uni[thread].meter.flag = TRUE;
< 		uni[thread].spec.flag = TRUE;
< 		top[thread].swch.env.fall.size = (int)(loc[thread].def.rate * 0.005);
< 		top[thread].swch.env.stdy.size = (int)(loc[thread].def.rate * 0.050);
< 		top[thread].swch.env.rise.size = (int)(loc[thread].def.rate * 0.005);
< 
< 
< 		top[thread].swch.env.curr.val = 0.0;
< 		top[thread].swch.env.curr.cnt = 0;
< 		top[thread].swch.env.rise.incr = 1.0f/(float)top[thread].swch.env.rise.size;
< 		top[thread].swch.env.fall.incr = 1.0f/(float)top[thread].swch.env.fall.size;
< 		//fprintf(stderr,"setup: switch done\n"),fflush(stderr);
< 		//fprintf(stderr,"setup: Entering workspace setup, thread %u\n", thread),fflush(stderr);
< 		setup_workspace (loc[thread].def.rate,
< 				loc[thread].def.size,
< 				loc[thread].def.mode,
< 				loc[thread].path.wisdom, loc[thread].def.spec, loc[thread].def.nrx, loc[thread].def.comp, thread);
< 		//fprintf(stderr,"setup: workspace done thread %u\n", thread),fflush(stderr);
< 
< 		setup_local_audio (thread);
< 		//fprintf(stderr,"setup: setup_local_audio done\n"),fflush(stderr);
< 		setup_system_audio (thread);
< 		//fprintf(stderr,"setup: setup_system_audio done\n"),fflush(stderr);
< 
< 		setup_threading (thread);
< 		//fprintf(stderr,"setup: threading done\n"),fflush(stderr);
< 
< 		// setup_switching ();
< 		uni[thread].spec.flag = TRUE;
< 		uni[thread].spec.type = SPEC_POST_FILT;
< 		uni[thread].spec.scale = SPEC_PWR;
< 		uni[thread].spec.rxk = 0;
< 		reset_meters (thread);
< 		reset_spectrum (thread);
< 		reset_counters (thread);
< 		//fprintf(stderr,"setup sdr thread %0u: done\n",thread),fflush(stderr);
< 	}
< }
< 
< BOOLEAN reset_buflen = FALSE;
< int
< reset_for_buflen (unsigned int thread, int new_buflen)
< {
< 	
< 
<   // make sure new size is power of 2
<   if (popcnt (new_buflen) != 1)
<     return -1;
<   reset_buflen = TRUE;
<   uni[thread].buflen = new_buflen;
<   top[thread].jack.reset_size = new_buflen;
<   safefree ((char *) top[thread].hold.buf.r);
<   safefree ((char *) top[thread].hold.buf.l);
<   safefree ((char *) top[thread].hold.aux.r);
<   safefree ((char *) top[thread].hold.aux.l);
<   
< 
<   destroy_workspace (thread);
<   reset_buflen = FALSE;
<   loc[thread].def.size = new_buflen;
<   setup_workspace (loc[thread].def.rate,
< 		   loc[thread].def.size,
< 		   loc[thread].def.mode,
< 		   loc[thread].path.wisdom, loc[thread].def.spec, loc[thread].def.nrx, loc[thread].def.size, thread);
< 
<   setup_local_audio (thread);
< 
<   reset_meters (thread);
<   reset_spectrum (thread);
<   reset_counters (thread);
< 
<   return 0;
< }
< 
< int
< reset_for_samplerate (REAL new_samplerate)
< {
< 
< 
<   unsigned int thread;
< 
<   for(thread=0; thread<MAX_THREADS; thread++) {
< 	
< 	safefree ((char *) top[thread].hold.buf.r);
<     safefree ((char *) top[thread].hold.buf.l);
<     safefree ((char *) top[thread].hold.aux.r);
<     safefree ((char *) top[thread].hold.aux.l);
< 	destroy_workspace (thread);
< 
< 	loc[thread].def.rate = uni[thread].samplerate = new_samplerate;
< 	top[thread].swch.env.fall.size = (int)(loc[thread].def.rate * 0.005);
< 	top[thread].swch.env.stdy.size = (int)(loc[thread].def.rate * 0.050);
< 	top[thread].swch.env.rise.size = (int)(loc[thread].def.rate * 0.005);
< 	top[thread].swch.env.curr.val = 0.0;
< 	top[thread].swch.env.curr.cnt = 0;
< 	top[thread].swch.env.fall.incr = 1.0f/(float)top[thread].swch.env.fall.size;
< 	top[thread].swch.env.rise.incr = 1.0f/(float)top[thread].swch.env.rise.size;
< 	setup_workspace (loc[thread].def.rate,
< 			loc[thread].def.size,
< 			loc[thread].def.mode,
< 			loc[thread].path.wisdom, loc[thread].def.spec, loc[thread].def.nrx, loc[thread].def.size,thread);
< 	setup_local_audio (thread);
< 
< 	reset_meters (thread);
< 	reset_spectrum (thread);
< 	reset_counters (thread);
<   }
<   return 0;
< }
---
> /* winmain.c
> 
> This file is part of a program that implements a Software-Defined Radio.
> 
> Copyright (C) 2004, 2005, 2006, 2007 by Frank Brickle, AB2KT and Bob McGwier, N4HY
> 
> This program is free software; you can redistribute it and/or modify
> it under the terms of the GNU General Public License as published by
> the Free Software Foundation; either version 2 of the License, or
> (at your option) any later version.
> 
> This program is distributed in the hope that it will be useful,
> but WITHOUT ANY WARRANTY; without even the implied warranty of
> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> GNU General Public License for more details.
> 
> You should have received a copy of the GNU General Public License
> along with this program; if not, write to the Free Software
> Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
> 
> The authors can be reached by email at
> 
> ab2kt@arrl.net
> or
> rwmcgwier@comcast.net
> 
> or by paper mail at
> 
> The DTTS Microwave Society
> 6 Kathleen Place
> Bridgewater, NJ 08807
> */
> 
> #include <common.h>
> /////////////////////////////////////////////////////////////////////////
> 
> // elementary defaults
> struct _loc loc[3];
> extern unsigned int threadno;
> /////////////////////////////////////////////////////////////////////////
> // most of what little we know here about the inner loop,
> // functionally speaking
> 
> extern void reset_meters (unsigned int);
> extern void reset_spectrum (unsigned int);
> extern void reset_counters (unsigned int);
> extern void process_samples (float *, float *, float *, float *, int, unsigned int);
> extern void setup_workspace (REAL rate,
> 			     int buflen,
> 			     SDRMODE mode,
> 			     char *wisdom,
> 			     int specsize, int numrecv, int cpdsize, unsigned int thread);
> extern void destroy_workspace (unsigned int thread);
> 
> 
> //========================================================================
> 
> //========================================================================
> 
> 
> 
> BOOLEAN reset_em;
> char *APP_DATA_PATH;
> 
> PRIVATE BOOLEAN
> gethold (unsigned int proc_thread)
> {
> 	if (ringb_float_read_space (top[proc_thread].jack.ring.i.l) >= top[proc_thread].hold.size.frames)
> 		{
> 			ringb_float_read (top[proc_thread].jack.ring.i.l,
> 				top[proc_thread].hold.buf.l, top[proc_thread].hold.size.frames);
> 			ringb_float_read (top[proc_thread].jack.ring.i.r,
> 				top[proc_thread].hold.buf.r, top[proc_thread].hold.size.frames);
> 	#ifdef USE_AUXILIARY
> 			ringb_float_read (top[proc_thread].jack.auxr.i.l,
> 				top[proc_thread].hold.aux.l, top[proc_thread].hold.size.frames);
> 			ringb_float_read (top[thread].jack.auxr.i.r,
> 				top[proc_thread].hold.aux.r, top[proc_thread].hold.size.frames);
> 	#else
> 			ringb_float_read (top[proc_thread].jack.auxr.i.l,
> 				top[proc_thread].hold.buf.l, top[proc_thread].hold.size.frames);
> 			ringb_float_read (top[proc_thread].jack.auxr.i.r,
> 				top[proc_thread].hold.buf.r, top[proc_thread].hold.size.frames);
> 	#endif
> 			return TRUE;
> 		} else return FALSE;
> 
> }
> PRIVATE void
> puthold(unsigned int proc_thread)
> {
> 	   if (ringb_float_write_space (top[proc_thread].jack.ring.o.l) >= top[proc_thread].hold.size.frames)
> 		{
> 			ringb_float_write (top[proc_thread].jack.ring.o.l, top[proc_thread].hold.buf.l,
> 				top[proc_thread].hold.size.frames);
> 			ringb_float_write (top[proc_thread].jack.ring.o.r, top[proc_thread].hold.buf.r,
> 				top[proc_thread].hold.size.frames);
> 	#ifdef USE_AUXILIARY
> 			ringb_float_write (top[proc_thread].jack.auxr.o.l, top[proc_thread].hold.aux.l,
> 				top[proc_thread].hold.size.frames);
> 			ringb_float_write (top[proc_thread].jack.auxr.o.r, top[proc_thread].hold.aux.r,
> 				top[proc_thread].hold.size.frames);
> 	#else
> 			ringb_float_write (top[proc_thread].jack.auxr.o.l, top[proc_thread].hold.buf.l,
> 				top[proc_thread].hold.size.frames);
> 			ringb_float_write (top[proc_thread].jack.auxr.o.r, top[proc_thread].hold.buf.r,
> 				top[proc_thread].hold.size.frames);
> 		}
> 	#endif
> 
> }
> PRIVATE BOOLEAN
> canhold (unsigned int proc_thread)
> {
> 
> 	return (ringb_float_read_space (top[proc_thread].jack.ring.i.l) >=
> 		(size_t) top[proc_thread].hold.size.frames);
> }
> 
> 
> //------------------------------------------------------------------------
> 
> PRIVATE void
> run_mute (unsigned int thread)
> {
> 	memset ((char *) top[thread].hold.buf.l, 0, top[thread].hold.size.bytes);
> 	memset ((char *) top[thread].hold.buf.r, 0, top[thread].hold.size.bytes);
> 	memset ((char *) top[thread].hold.aux.l, 0, top[thread].hold.size.bytes);
> 	memset ((char *) top[thread].hold.aux.r, 0, top[thread].hold.size.bytes);
> 	uni[thread].tick++;
> }
> 
> PRIVATE void
> run_pass (unsigned int thread)
> {
> 	uni[thread].tick++;
> }
> 
> PRIVATE void
> run_play (unsigned int thread)
> {
> 	process_samples (top[thread].hold.buf.l, top[thread].hold.buf.r,
> 		top[thread].hold.aux.l, top[thread].hold.aux.r, top[thread].hold.size.frames, thread);
> }
> 
> // NB do not set RUN_SWCH directly via setRunState;
> // use setSWCH instead
> 
> 
> PRIVATE void
> run_swch(unsigned int thread)
> {
> 	int i, n = top[thread].hold.size.frames;
> 	REAL w;
> //	static int count = 0;
> 
> 	process_samples(top[thread].hold.buf.l, top[thread].hold.buf.r,
> 		top[thread].hold.aux.l, top[thread].hold.aux.r,
> 		top[thread].hold.size.frames, thread);
> 
> 	for (i = 0; i < n; i++)
> 	{
> //		count++;
> 		if (top[thread].swch.env.curr.type == SWCH_FALL)
> 		{
> 			top[thread].swch.env.curr.val += top[thread].swch.env.fall.incr;
> 			w = (REAL)sin(top[thread].swch.env.curr.val * M_PI /  2.0f);
> 			top[thread].hold.buf.l[thread] *= w, top[thread].hold.buf.r[thread] *= w;
> 			top[thread].hold.aux.l[thread] *= w, top[thread].hold.aux.r[thread] *= w;
> //			if (top[thread].swch.env.curr.cnt == 0) fprintf(stderr, "FALL\n"),fflush(stderr);
> //			if(top[thread].swch.env.curr.cnt == 0) top[thread].hold.buf.l[thread] = top[thread].hold.buf.r[thread] = -1.0;
> 			if (++top[thread].swch.env.curr.cnt >= top[thread].swch.env.fall.size)
> 			{
> 				//top[thread].hold.buf.l[thread] = top[thread].hold.buf.r[thread] = -1.0;
> 				top[thread].swch.env.curr.type = SWCH_STDY;
> 				top[thread].swch.env.curr.cnt = 0;
> 				top[thread].swch.env.curr.val = 0.0;
> //				fprintf(stderr, "Fall End: %d\n", count);
> 			}
> 		}
> 		else if (top[thread].swch.env.curr.type == SWCH_STDY)
> 		{
> 			top[thread].hold.buf.l[i]= top[thread].hold.buf.r[i] =
> 				top[thread].hold.aux.l[i] =  top[thread].hold.aux.r[i] = 0.0;
> //			if (top[thread].swch.env.curr.cnt == 0) fprintf(stderr, "STDY\n"),fflush(stderr);
> 			if (++top[thread].swch.env.curr.cnt >= top[thread].swch.env.stdy.size)
> 			{
> //				top[thread].hold.buf.l[thread] = top[thread].hold.buf.r[thread] = -1.0;
> 				top[thread].swch.env.curr.type = SWCH_RISE;
> 				top[thread].swch.env.curr.cnt = 0;
> 				top[thread].swch.env.curr.val = 0.0;
> //				fprintf(stderr, "Stdy End: %d\n", count);
> 			}
> 		}
> 		else if (top[thread].swch.env.curr.type == SWCH_RISE)
> 		{
> 			top[thread].swch.env.curr.val += top[thread].swch.env.rise.incr;
> 			w = (REAL)sin(top[thread].swch.env.curr.val * M_PI /  2.0f);
> 			top[thread].hold.buf.l[i] *= w, top[thread].hold.buf.r[i] *= w;
> 			top[thread].hold.aux.l[i] *= w, top[thread].hold.aux.r[i] *= w;
> //			if (top[thread].swch.env.curr.cnt == 0) fprintf(stderr, "RISE\n"),fflush(stderr);
> 			if (++top[thread].swch.env.curr.cnt >= top[thread].swch.env.rise.size)
> 			{
> //				reset_meters();
> //				reset_spectrum();
> //				reset_counters();
> 	
> 				uni[thread].mode.trx = top[thread].swch.trx.next;
> 				top[thread].state = top[thread].swch.run.last;
> 				break;
> //				fprintf(stderr, "Rise End: %d\n", count);
> 			}
> 		}
> 	}
> }
> 
> 
> //========================================================================
> 
> static void reset_system_audio(size_t nframes)
> {
> 	size_t reset_size;
> 	unsigned int thread;
> 	const float zero = 0.;
> 	int i;
> 
> 	reset_em = FALSE;
> 	for(thread = 0; thread < threadno; thread++) 
> 	{
> 		reset_size = max (top[thread].jack.reset_size, nframes);
> 		ringb_float_reset (top[thread].jack.ring.i.l);
> 		ringb_float_reset (top[thread].jack.ring.i.r);
> 		ringb_float_reset (top[thread].jack.auxr.i.l);
> 		ringb_float_reset (top[thread].jack.auxr.i.r);
> 		ringb_float_clear (top[thread].jack.ring.i.l, top[thread].jack.size * loc[thread].mult.ring-1);
> 		ringb_float_clear (top[thread].jack.ring.i.l, top[thread].jack.size * loc[thread].mult.ring-1);
> 		ringb_float_reset (top[thread].jack.ring.i.l);
> 		ringb_float_reset (top[thread].jack.ring.i.r);
> //		ringb_float_reset (top[thread].jack.auxr.i.l);
> //		ringb_float_reset (top[thread].jack.auxr.i.r);
> 	
> 		if (top[thread].offset < 0)
> 		{
> 			for(i=top[thread].offset;i<0;i++)
> 			{
> 				ringb_float_write(top[thread].jack.ring.i.l,&zero,1);
> 				ringb_float_write(top[thread].jack.auxr.i.l,&zero,1);
> 				//ringb_float_write(top[thread].jack.auxr.i.l,&zero,1);
> 			}
> 		}
> 		else
> 		{
> 			for(i=0;i<top[thread].offset;i++)
> 			{
> 				ringb_float_write(top[thread].jack.ring.i.r,&zero,1);
> 				ringb_float_write(top[thread].jack.auxr.i.r,&zero,1);
> 				//ringb_float_write(top[thread].jack.auxr.i.r,&zero,1);
> 			}
> 		}
> 
> 		ringb_float_restart (top[thread].jack.ring.o.r, reset_size);
> 		ringb_float_restart (top[thread].jack.ring.o.l, reset_size);
> 		ringb_float_restart (top[thread].jack.auxr.o.r, reset_size);
> 		ringb_float_restart (top[thread].jack.auxr.o.l, reset_size);
> 		//ringb_float_restart (top[thread].jack.auxr.o.r, reset_size);
> 		//ringb_float_restart (top[thread].jack.auxr.o.l, reset_size);
> 	}
> }
> 
> DttSP_EXP void
> Audio_Callback (float *input_l, float *input_r, float *output_l,
> 	float *output_r, unsigned int nframes)
> {
> 	BOOLEAN b = reset_em;
> 	int i;
> 	if (top[0].susp)
> 	{
> 		memset (output_l, 0, nframes * sizeof (float));
> 		memset (output_r, 0, nframes * sizeof (float));
> 		return;
> 	}
> 
> 	if (b)
> 	{
> 		//fprintf(stdout,"Audio_Callback: call reset_system_audio\n"), fflush(stdout);
> 		reset_system_audio(nframes);
> 		memset (output_l, 0, nframes * sizeof (float));
> 		memset (output_r, 0, nframes * sizeof (float));
> 		return;
>     }
> 
> 	for (i=0; i<2; i++) 
> 	{
> 		if ((ringb_float_read_space (top[i].jack.ring.o.l) >= nframes)
> 			&& (ringb_float_read_space (top[i].jack.ring.o.r) >= nframes))
> 		{
> 			if (top[i].state == RUN_PLAY)
> 			{
> 				ringb_float_read (top[i].jack.auxr.o.l, output_l, nframes);
> 				ringb_float_read (top[i].jack.auxr.o.r, output_r, nframes);
> 				ringb_float_read (top[i].jack.ring.o.l, output_l, nframes);
> 				ringb_float_read (top[i].jack.ring.o.r, output_r, nframes);
> 			}
> 			else
> 			{
> 				ringb_float_read_advance (top[i].jack.auxr.o.l, nframes);
> 				ringb_float_read_advance (top[i].jack.auxr.o.r, nframes);
> 				ringb_float_read_advance (top[i].jack.ring.o.l, nframes);
> 				ringb_float_read_advance (top[i].jack.ring.o.r, nframes);
> 
> 			}
> 		}
> 		else
> 		{	// rb pathology
> 			//fprintf(stdout,"Audio_Callback-2: rb out pathology\n"), fflush(stdout);
> 			reset_system_audio(nframes);
> 			memset (output_l, 0, nframes * sizeof (float));
> 			memset (output_r, 0, nframes * sizeof (float));
> 		}
> 
> 		// input: copy from port to ring
> 		if ((ringb_float_write_space (top[i].jack.ring.i.l) >= nframes)
> 			&& (ringb_float_write_space (top[i].jack.ring.i.r) >= nframes))
> 		{
> 			ringb_float_write (top[i].jack.ring.i.l, (float *) input_l, nframes);
> 			ringb_float_write (top[i].jack.ring.i.r, (float *) input_r, nframes);
> 			ringb_float_write (top[i].jack.auxr.i.l, (float *) input_l, nframes);
> 			ringb_float_write (top[i].jack.auxr.i.r, (float *) input_r, nframes);
> 		}
> 		else
> 		{	// rb pathology
> 			//fprintf(stdout,"Audio_Callback-3: rb in pathology\n"), fflush(stdout);
> 			reset_system_audio(nframes);
> 			memset (output_l, 0, nframes * sizeof (float));
> 			memset (output_r, 0, nframes * sizeof (float));
> 		}
> 
> 		// if enough accumulated in ring, fire dsp
> 		if (ringb_float_read_space (top[i].jack.ring.i.l) >= top[i].hold.size.frames)
> 			sem_post (&top[i].sync.buf.sem);
> 	}
> }
> 
> DttSP_EXP void
> Audio_Callback2 (float **input, float **output, unsigned int nframes)
> {
> 	unsigned int thread;
> 	BOOLEAN b = reset_em;
> 	BOOLEAN return_empty=FALSE;
> 	unsigned int i;
> 	for(thread=0;thread<threadno;thread++)
> 	{
> 		if (top[thread].susp) return_empty = TRUE;
> 	}
> 
> 	if (return_empty)
> 	{
> 		for(thread=0;thread<threadno;thread++) 
> 		{
> 			memset (output[2*thread], 0, nframes * sizeof (float));
> 			memset (output[2*thread+1], 0, nframes * sizeof (float));
> 		}
> 		return;
> 	}
> 
> 	if (b)
> 	{
> 		//fprintf(stderr, "reset_em!\n"); fflush(stderr);
> 		//fprintf(stdout,"Audio_Callback2: reset_em = TRUE\n"), fflush(stdout);
> 		reset_system_audio(nframes);
> 		for(thread=0;thread<threadno;thread++) {
> 			memset (output[2*thread], 0, nframes * sizeof (float));
> 			memset (output[2*thread+1], 0, nframes * sizeof (float));
> 		}
> 		return;
>     }
> #if 0
> 	if (diversity.flag) {
> 		// Deal with the transmitter first
> 		if ((ringb_float_read_space (top[1].jack.ring.o.l) >= nframes)
> 			&& (ringb_float_read_space (top[1].jack.ring.o.r) >= nframes))
> 		{
> 			ringb_float_read (top[1].jack.ring.o.l, output[2], nframes);
> 			ringb_float_read (top[1].jack.ring.o.r, output[3], nframes);
> 		}
> 		else
> 		{	
> 			// rb pathology
> 			//reset_system_audio(nframes);
> 			for(thread=0;thread<threadno;thread++) 
> 			{
> 				memset (output[thread], 0, nframes * sizeof (float));
> 				memset (output[thread], 0, nframes * sizeof (float));
> 			}
> 			return;
> 		}
> 
> 		// input: copy from port to ring
> 		if ((ringb_float_write_space (top[1].jack.ring.i.l) >= nframes)
> 			&& (ringb_float_write_space (top[1].jack.ring.i.r) >= nframes))
> 		{
> 			ringb_float_write (top[1].jack.ring.i.l, input[2], nframes);
> 			ringb_float_write (top[1].jack.ring.i.r, input[3], nframes);
> 		}
> 		else
> 		{	
> 			// rb pathology
> 			for(thread=0;thread<threadno;thread++) 
> 			{
> 				memset (output[thread], 0, nframes * sizeof (float));
> 				memset (output[thread], 0, nframes * sizeof (float));
> 			}
> 			return;
> 		}
> 		
> 		// if enough accumulated in ring, fire dsp
> 		if ((ringb_float_read_space (top[1].jack.ring.i.l) >= top[1].hold.size.frames) &&
> 			(ringb_float_read_space (top[1].jack.ring.i.r) >= top[1].hold.size.frames))
> 			sem_post (&top[1].sync.buf.sem);
> 
> 		//		
> 		// Deal with the diversity channel next
> 		//
> 		if ((ringb_float_read_space (top[0].jack.ring.o.l) >= nframes)
> 			&& (ringb_float_read_space (top[0].jack.ring.o.r) >= nframes))
> 		{
> 			/*ringb_float_read (top[thread].jack.auxr.o.l, output[l], nframes);
> 			ringb_float_read (top[thread].jack.auxr.o.r, output[r], nframes);*/
> 			ringb_float_read (top[0].jack.ring.o.l, output[2], nframes);
> 			ringb_float_read (top[0].jack.ring.o.r, output[3], nframes);
> 		}
> 		else
> 		{	
> 			// rb pathology
> 			//reset_system_audio(nframes);
> 			for(thread=0;thread<threadno;thread++) 
> 			{
> 				memset (output[thread], 0, nframes * sizeof (float));
> 				memset (output[thread], 0, nframes * sizeof (float));
> 			}
> 			return;
> 		}
> 
> 		// Deal with the diversity/phased array channel next
> 
> 		// input: copy from port to ring
> 		if ((ringb_float_write_space (top[0].jack.ring.i.l) >= nframes)
> 			&& (ringb_float_write_space (top[0].jack.ring.i.r) >= nframes) &&
> 			(ringb_float_write_space (top[2].jack.ring.i.l) >= nframes)
> 			&& (ringb_float_write_space (top[2].jack.ring.i.r) >= nframes))
> 		{
> 			REAL *l0 = input[0];
> 			REAL *r0 = input[1];
> 			REAL *l2 = input[4];
> 			REAL *r2 = input[5];
> 			for (i=0;i<nframes;i++) {
> 				COMPLEX A = Cmplx(l0[i],r0[i]);
> 				COMPLEX B = Cmplx(l2[i],r2[i]);
> 				A = Cscl(Cadd(A,Cmul(B,diversity.scalar)),diversity.gain);
> 				ringb_float_write (top[0].jack.ring.i.l, &A.re, 1);
> 				ringb_float_write (top[0].jack.ring.i.r, &A.im, 1);
> 			}
> 			/*ringb_float_write (top[thread].jack.auxr.i.l, input[l], nframes);
> 			ringb_float_write (top[thread].jack.auxr.i.r, input[r], nframes);*/
> 		}
> 		else
> 		{	
> 			// rb pathology
> 			//reset_system_audio(nframes);
> 			for(thread=0;thread<threadno;thread++) 
> 			{
> 				memset (output[thread], 0, nframes * sizeof (float));
> 				memset (output[thread], 0, nframes * sizeof (float));
> 			}
> 			return;
> 		}
> 		
> 		// if enough accumulated in ring, fire dsp
> 		if ((ringb_float_read_space (top[0].jack.ring.i.l) >= top[0].hold.size.frames) &&
> 			(ringb_float_read_space (top[0].jack.ring.i.r) >= top[0].hold.size.frames))
> 			sem_post (&top[0].sync.buf.sem);
> 
> 
> 		//
> 		//  Deal with 2nd receiver channel now
> 		//
> 
> 		if ((ringb_float_read_space (top[2].jack.ring.o.l) >= nframes)
> 			&& (ringb_float_read_space (top[2].jack.ring.o.r) >= nframes))
> 		{
> 			/*ringb_float_read (top[thread].jack.auxr.o.l, output[l], nframes);
> 			ringb_float_read (top[thread].jack.auxr.o.r, output[r], nframes);*/
> 			ringb_float_read (top[2].jack.ring.o.l, output[4], nframes);
> 			ringb_float_read (top[2].jack.ring.o.r, output[5], nframes);
> 		}
> 		else
> 		{	
> 			// rb pathology
> 			//reset_system_audio(nframes);
> 			for(thread=0;thread<threadno;thread++) 
> 			{
> 				memset (output[thread], 0, nframes * sizeof (float));
> 				memset (output[thread], 0, nframes * sizeof (float));
> 			}
> 			return;
> 		}
> 
> 		// input: copy from port to ring
> 		if ((ringb_float_write_space (top[2].jack.ring.i.l) >= nframes)
> 			&& (ringb_float_write_space (top[2].jack.ring.i.r) >= nframes))
> 		{
> 			ringb_float_write (top[2].jack.ring.i.l, input[4], nframes);
> 			ringb_float_write (top[2].jack.ring.i.r, input[5], nframes);
> 		}
> 		else
> 		{	
> 			// rb pathology
> 			for(thread=0;thread<threadno;thread++) 
> 			{
> 				memset (output[thread], 0, nframes * sizeof (float));
> 				memset (output[thread], 0, nframes * sizeof (float));
> 			}
> 			return;
> 		}
> 		
> 		// if enough accumulated in ring, fire dsp
> 		if ((ringb_float_read_space (top[2].jack.ring.i.l) >= top[2].hold.size.frames) &&
> 			(ringb_float_read_space (top[2].jack.ring.i.r) >= top[2].hold.size.frames))
> 			sem_post (&top[2].sync.buf.sem);
> 
> 	} else
> #endif
> 	for(thread=0; thread<threadno; thread++) 
> 	{
> 		int l=2*thread, r = 2*thread+1;
> 		if ((ringb_float_read_space (top[thread].jack.ring.o.l) >= nframes)
> 			&& (ringb_float_read_space (top[thread].jack.ring.o.r) >= nframes))
> 		{
> 			/*ringb_float_read (top[thread].jack.auxr.o.l, output[l], nframes);
> 			ringb_float_read (top[thread].jack.auxr.o.r, output[r], nframes);*/
> 			ringb_float_read (top[thread].jack.ring.o.l, output[l], nframes);
> 			ringb_float_read (top[thread].jack.ring.o.r, output[r], nframes);
> 		}
> 		else
> 		{	
> 			// rb pathology
> 			//reset_system_audio(nframes);
> 			for(thread=0;thread<threadno;thread++) 
> 			{
> 				memset (output[2*thread  ], 0, nframes * sizeof (float));
> 				memset (output[2*thread+1], 0, nframes * sizeof (float));
> 			}
> 			return;
> 		}
> 
> 		// input: copy from port to ring
> 		if ((ringb_float_write_space (top[thread].jack.ring.i.l) >= nframes)
> 			&& (ringb_float_write_space (top[thread].jack.ring.i.r) >= nframes))
> 		{
> 			if (diversity.flag && (thread == 0)) {
> 				if ((ringb_float_write_space (top[2].jack.ring.i.l) >= nframes)
> 					&& (ringb_float_write_space (top[2].jack.ring.i.r) >= nframes))
> 				{
> 					REAL *l0 = input[0];
> 					REAL *r0 = input[1];
> 					REAL *l2 = input[4];
> 					REAL *r2 = input[5];
> 					for (i=0;i<nframes;i++) {
> 						COMPLEX A = Cmplx(l0[i],r0[i]);
> 						COMPLEX B = Cmplx(l2[i],r2[i]);
> 						A = Cscl(Cadd(A,Cmul(B,diversity.scalar)),diversity.gain);
> 						ringb_float_write (top[0].jack.ring.i.l, &A.re, 1);
> 						ringb_float_write (top[0].jack.ring.i.r, &A.im, 1);
> 					}
> 					/*ringb_float_write (top[thread].jack.auxr.i.l, input[l], nframes);
> 					ringb_float_write (top[thread].jack.auxr.i.r, input[r], nframes);*/
> 				} else {
> 					// rb pathology
> 					//reset_system_audio(nframes);
> 					for(thread=0;thread<threadno;thread++) 
> 					{
> 						memset (output[2*thread  ], 0, nframes * sizeof (float));
> 						memset (output[2*thread+1], 0, nframes * sizeof (float));
> 					}
> 					return;
> 				}
> 			} else {
> 				ringb_float_write (top[thread].jack.ring.i.l, input[l], nframes);
> 				ringb_float_write (top[thread].jack.ring.i.r, input[r], nframes);
> 				/*ringb_float_write (top[thread].jack.auxr.i.l, input[l], nframes);
> 				ringb_float_write (top[thread].jack.auxr.i.r, input[r], nframes);*/
> 			}
> 		}
> 		else
> 		{	
> 			// rb pathology
> 			//reset_system_audio(nframes);
> 			for(thread=0;thread<threadno;thread++) 
> 			{
> 				memset (output[2*thread  ], 0, nframes * sizeof (float));
> 				memset (output[2*thread+1], 0, nframes * sizeof (float));
> 			}
> 			return;
> 		}
> 		
> 		// if enough accumulated in ring, fire dsp
> 		if ((ringb_float_read_space (top[thread].jack.ring.i.l) >= top[thread].hold.size.frames) &&
> 			(ringb_float_read_space (top[thread].jack.ring.i.r) >= top[thread].hold.size.frames))
> 			sem_post (&top[thread].sync.buf.sem);
> 	}
> }
> 
> 
> //========================================================================
> 
> 
> DttSP_EXP void
> process_samples_thread (unsigned int proc_thread)
> {
> 	while (top[proc_thread].running)
> 	{
> 		sem_wait (&top[proc_thread].sync.buf.sem);
> 		while (gethold(proc_thread)) 
> 		{
> 			sem_wait (&top[proc_thread].sync.upd.sem);
> 			switch (top[proc_thread].state)
> 			{
> 				case RUN_MUTE:
> 					run_mute (proc_thread);
> 					break;
> 				case RUN_PASS:
> 					run_pass (proc_thread);
> 					break;
> 				case RUN_PLAY:
> 					run_play (proc_thread);
> 					break;
> 				case RUN_SWCH:
> 					run_swch (proc_thread);
> 					break;
> 			}
> 			sem_post (&top[proc_thread].sync.upd.sem);
> 			puthold (proc_thread);
> 		}
> 	}
> }
> 
> 
> 
> void
> closeup ()
> {
> 	unsigned int thread;
> 	for(thread = 0; thread<3;thread++) 
> 	{
> 		top[thread].running = FALSE;
> 		top[thread].susp = TRUE;
> 		Sleep (96);
> 		ringb_float_free (top[thread].jack.auxr.i.l);
> 		ringb_float_free (top[thread].jack.auxr.i.r);
> 		ringb_float_free (top[thread].jack.auxr.o.l);
> 		ringb_float_free (top[thread].jack.auxr.o.r);
> 
> 		ringb_float_free (top[thread].jack.ring.o.r);
> 		ringb_float_free (top[thread].jack.ring.o.l);
> 		ringb_float_free (top[thread].jack.ring.i.r);
> 		ringb_float_free (top[thread].jack.ring.i.l);
> 
> 		destroy_workspace (thread);
> 	}
> 	Sleep(100);
> 	//fprintf(stderr,"Done with destructor\n"),fflush(stderr);
> }
> 
> 
> 
> PRIVATE void
> setup_local_audio (unsigned int thread)
> {
> 	top[thread].hold.size.frames = uni[thread].buflen;
> 	top[thread].hold.size.bytes = top[thread].hold.size.frames * sizeof (float);
> 	top[thread].hold.buf.l =
> 		(float *) safealloc (top[thread].hold.size.frames, sizeof (float),
> 		"main hold buffer left");
> 	top[thread].hold.buf.r =
> 		(float *) safealloc (top[thread].hold.size.frames, sizeof (float),
> 		"main hold buffer right");
> 	top[thread].hold.aux.l =
> 		(float *) safealloc (top[thread].hold.size.frames, sizeof (float),
> 		"aux hold buffer left");
> 	top[thread].hold.aux.r =
> 		(float *) safealloc (top[thread].hold.size.frames, sizeof (float),
> 			"aux hold buffer right");
> }
> 
> 
> PRIVATE void
> setup_system_audio (unsigned int thread)
> {
> 
> 	sprintf (top[thread].jack.name, "sdr-%d-%0u", top[thread].pid,thread);
> 	top[thread].jack.size = 2048;
> 
> 	memset ((char *) &top[thread].jack.blow, 0, sizeof (top[thread].jack.blow));
> 	top[thread].jack.ring.i.l = ringb_float_create (top[thread].jack.size * loc[thread].mult.ring);
> 	top[thread].jack.ring.i.r = ringb_float_create (top[thread].jack.size * loc[thread].mult.ring);
> 	top[thread].jack.ring.o.l = ringb_float_create (top[thread].jack.size * loc[thread].mult.ring);
> 	top[thread].jack.ring.o.r = ringb_float_create (top[thread].jack.size * loc[thread].mult.ring);
> 	top[thread].jack.auxr.i.l = ringb_float_create (top[thread].jack.size * loc[thread].mult.ring);
> 	top[thread].jack.auxr.i.r = ringb_float_create (top[thread].jack.size * loc[thread].mult.ring);
> 	top[thread].jack.auxr.o.l = ringb_float_create (top[thread].jack.size * loc[thread].mult.ring);
> 	top[thread].jack.auxr.o.r = ringb_float_create (top[thread].jack.size * loc[thread].mult.ring);
> 	ringb_float_clear (top[thread].jack.ring.o.l, top[thread].hold.size.frames);
> 	ringb_float_clear (top[thread].jack.ring.o.r, top[thread].hold.size.frames);
> }
> 
> PRIVATE void
> setup_threading (unsigned int thread)
> {
> 	top[thread].susp = FALSE;
> 	sem_init (&top[thread].sync.upd.sem, 0, 0);
> 	sem_init (&top[thread].sync.buf.sem, 0, 0);	
> }
> 
> //========================================================================
> // hard defaults, then environment
> 
> PRIVATE void
> setup_defaults (unsigned int thread)
> {
> 	//fprintf(stderr,"I am inside setup defaults thread: %0u\n",thread),fflush(stderr);
> 	loc[thread].name[0] = 0;		// no default name for jack client
> 	sprintf (loc[thread].path.rcfile, "%s%0lu_%0u", RCBASE, top[thread].pid,thread);
> 	sprintf (loc[thread].path.parm, "%s%0lu_%0u", PARMPATH, top[thread].pid,thread);
> 	sprintf (loc[thread].path.meter, "%s%0lu_%0u", METERPATH, top[thread].pid,thread);
> 	sprintf (loc[thread].path.spec, "%s%0lu_%0u", SPECPATH, top[thread].pid,thread);
> 	sprintf (loc[thread].path.wisdom, "%s%0lu_%0u", WISDOMPATH, top[thread].pid,thread);
> 	loc[thread].def.rate = DEFRATE;
> 	loc[thread].def.size = DEFSIZE;
> 	loc[thread].def.nrx = MAXRX;
> 	loc[thread].def.mode = DEFMODE;
> 	loc[thread].def.spec = DEFSPEC;
> 	loc[thread].mult.ring = RINGMULT;
> 	loc[thread].def.comp = DEFCOMP;
> }
> 
> //========================================================================
> void
> setup (char *app_data_path)
> {
> 	unsigned int thread;
> 	//fprintf(stderr,"I am inside setup\n"),fflush(stderr);
> 	diversity.gain = 1;
> 	diversity.flag = FALSE;
> 	diversity.scalar = cxzero;
> 
> 	APP_DATA_PATH=app_data_path;
> 	for (thread=0;thread<3;thread++) 
> 	{
> 		top[thread].pid = GetCurrentThreadId ();
> 		top[thread].uid = 0L;
> 		top[thread].start_tv = now_tv ();
> 		top[thread].running = TRUE;
> 		top[thread].verbose = FALSE;
> 		if (thread != 1) top[thread].state = RUN_PLAY;
> 		else top[thread].state = RUN_PASS;
> 		top[thread].offset = 0;
> 		top[thread].jack.reset_size = 2048;
> 		reset_em =TRUE;
> 		setup_defaults (thread);
> 		strcpy(loc[thread].path.wisdom,app_data_path);
> 		
> 		//fprintf(stderr,"setup: defaults done thread %u\n", thread),fflush(stderr);
> 		uni[thread].meter.flag = TRUE;
> 		uni[thread].spec.flag = TRUE;
> 		top[thread].swch.env.fall.size = (int)(loc[thread].def.rate * 0.005);
> 		top[thread].swch.env.stdy.size = (int)(loc[thread].def.rate * 0.050);
> 		top[thread].swch.env.rise.size = (int)(loc[thread].def.rate * 0.005);
> 
> 
> 		top[thread].swch.env.curr.val = 0.0;
> 		top[thread].swch.env.curr.cnt = 0;
> 		top[thread].swch.env.rise.incr = 1.0f/(float)top[thread].swch.env.rise.size;
> 		top[thread].swch.env.fall.incr = 1.0f/(float)top[thread].swch.env.fall.size;
> 		//fprintf(stderr,"setup: switch done\n"),fflush(stderr);
> 		//fprintf(stderr,"setup: Entering workspace setup, thread %u\n", thread),fflush(stderr);
> 		setup_workspace (loc[thread].def.rate,
> 				loc[thread].def.size,
> 				loc[thread].def.mode,
> 				app_data_path, loc[thread].def.spec, loc[thread].def.nrx, loc[thread].def.comp, thread);
> 		//fprintf(stderr,"setup: workspace done thread %u\n", thread),fflush(stderr);
> 
> 		setup_local_audio (thread);
> 		//fprintf(stderr,"setup: setup_local_audio done\n"),fflush(stderr);
> 		setup_system_audio (thread);
> 		//fprintf(stderr,"setup: setup_system_audio done\n"),fflush(stderr);
> 
> 		setup_threading (thread);
> 		//fprintf(stderr,"setup: threading done\n"),fflush(stderr);
> 
> 		// setup_switching ();
> 		uni[thread].spec.flag = TRUE;
> 		uni[thread].spec.type = SPEC_POST_FILT;
> 		uni[thread].spec.scale = SPEC_PWR;
> 		uni[thread].spec.rxk = 0;
> 		reset_meters (thread);
> 		reset_spectrum (thread);
> 		reset_counters (thread);
> 		//fprintf(stderr,"setup sdr thread %0u: done\n",thread),fflush(stderr);
> 	}
> }
> 
> //BOOLEAN reset_buflen = FALSE;
> int
> reset_for_buflen (unsigned int thread, int new_buflen)
> {
> 	// make sure new size is power of 2
> 	if (popcnt (new_buflen) != 1)
> 		return -1;
> //	reset_buflen = TRUE;
> 	uni[thread].buflen = new_buflen;
> 	top[thread].jack.reset_size = new_buflen;
> 	safefree ((char *) top[thread].hold.buf.r);
> 	safefree ((char *) top[thread].hold.buf.l);
> 	safefree ((char *) top[thread].hold.aux.r);
> 	safefree ((char *) top[thread].hold.aux.l);
> 
> 	destroy_workspace (thread);
> //	reset_buflen = FALSE;
> 	loc[thread].def.size = new_buflen;
> 	setup_workspace (loc[thread].def.rate,
> 		   loc[thread].def.size,
> 		   loc[thread].def.mode,
> 		   APP_DATA_PATH, loc[thread].def.spec, loc[thread].def.nrx, loc[thread].def.size, thread);
> 
> 	setup_local_audio (thread);
> 
> 	reset_meters (thread);
> 	reset_spectrum (thread);
> 	reset_counters (thread);
> 
> 	return 0;
> }
> 
> int
> reset_for_samplerate (REAL new_samplerate)
> {
> 	unsigned int thread;
> 
> 	for(thread=0; thread<3; thread++) 
> 	{	
> 		safefree ((char *) top[thread].hold.buf.r);
> 		safefree ((char *) top[thread].hold.buf.l);
> 		safefree ((char *) top[thread].hold.aux.r);
> 		safefree ((char *) top[thread].hold.aux.l);
> 		destroy_workspace (thread);
> 
> 		loc[thread].def.rate = uni[thread].samplerate = new_samplerate;
> 		top[thread].swch.env.fall.size = (int)(loc[thread].def.rate * 0.005);
> 		top[thread].swch.env.stdy.size = (int)(loc[thread].def.rate * 0.050);
> 		top[thread].swch.env.rise.size = (int)(loc[thread].def.rate * 0.005);
> 		top[thread].swch.env.curr.val = 0.0;
> 		top[thread].swch.env.curr.cnt = 0;
> 		top[thread].swch.env.fall.incr = 1.0f/(float)top[thread].swch.env.fall.size;
> 		top[thread].swch.env.rise.incr = 1.0f/(float)top[thread].swch.env.rise.size;
> 		setup_workspace (loc[thread].def.rate,
> 				loc[thread].def.size,
> 				loc[thread].def.mode,
> 				APP_DATA_PATH, loc[thread].def.spec, loc[thread].def.nrx, loc[thread].def.size,thread);
> 		setup_local_audio (thread);
> 
> 		reset_meters (thread);
> 		reset_spectrum (thread);
> 		reset_counters (thread);
> 	}
> 	return 0;
> }
diff ./wscompand.c /home/john/PowerSDR/PowerSDR_v2.0.16/Source/DttSP/wscompand.c
1,43c1,43
< // wscompand.c
< // waveshaping compander, mostly for speech
< /*
< This file is part of a program that implements a Software-Defined Radio.
< 
< Copyright (C) 2004, 2005, 2006 by Frank Brickle, AB2KT and Bob McGwier, N4HY
< 
< This program is free software; you can redistribute it and/or modify
< it under the terms of the GNU General Public License as published by
< the Free Software Foundation; either version 2 of the License, or
< (at your option) any later version.
< 
< This program is distributed in the hope that it will be useful,
< but WITHOUT ANY WARRANTY; without even the implied warranty of
< MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
< GNU General Public License for more details.
< 
< You should have received a copy of the GNU General Public License
< along with this program; if not, write to the Free Software
< Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
< 
< The authors can be reached by email at
< 
< ab2kt@arrl.net
< or
< rwmcgwier@comcast.net
< 
< or by paper mail at
< 
< The DTTS Microwave Society
< 6 Kathleen Place
< Bridgewater, NJ 08807
< */
< 
< #include <wscompand.h>
< 
< PRIVATE INLINE REAL
< WSCLookup (WSCompander wsc, REAL x)
< {
< 	if (x > 0.0)
< 	{
< 		/*REAL d = x - (int) x, y, *tbl = wsc->tbl;
< 		int i = (int) (x * wsc->npts), end = wsc->nend;*/
---
> // wscompand.c
> // waveshaping compander, mostly for speech
> /*
> This file is part of a program that implements a Software-Defined Radio.
> 
> Copyright (C) 2004, 2005, 2006 by Frank Brickle, AB2KT and Bob McGwier, N4HY
> 
> This program is free software; you can redistribute it and/or modify
> it under the terms of the GNU General Public License as published by
> the Free Software Foundation; either version 2 of the License, or
> (at your option) any later version.
> 
> This program is distributed in the hope that it will be useful,
> but WITHOUT ANY WARRANTY; without even the implied warranty of
> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> GNU General Public License for more details.
> 
> You should have received a copy of the GNU General Public License
> along with this program; if not, write to the Free Software
> Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
> 
> The authors can be reached by email at
> 
> ab2kt@arrl.net
> or
> rwmcgwier@comcast.net
> 
> or by paper mail at
> 
> The DTTS Microwave Society
> 6 Kathleen Place
> Bridgewater, NJ 08807
> */
> 
> #include <wscompand.h>
> 
> PRIVATE INLINE REAL
> WSCLookup (WSCompander wsc, REAL x)
> {
> 	if (x > 0.0)
> 	{
> 		/*REAL d = x - (int) x, y, *tbl = wsc->tbl;
> 		int i = (int) (x * wsc->npts), end = wsc->nend;*/
46,123c46,123
< 
< 		if (i < end)
< 			y = tbl[i] + d * (tbl[i + 1] - tbl[i]);
< 		else
< 			y = tbl[end];
< 		return y / x;
< 	}
< 	else
< 	{
< 		return 0.0;
< 	}
< }
< 
< void
< WSCompand (WSCompander wsc)
< {
< 	int i, n = CXBsize (wsc->buff);
< 
< 	if (wsc->fac != 0.0) 
< 	{
< 		for (i = 0; i < n ; i++)
< 		{
< 			COMPLEX val = CXBdata (wsc->buff, i);
< 			REAL mag = Cmag (val), scl = WSCLookup (wsc, mag);
< 			CXBdata (wsc->buff, i) = Cscl (val,scl);
< 		}
< 	}
< }
< 
< void
< WSCReset (WSCompander wsc, REAL fac)
< {
< 	int i;
< 	REAL *tbl = wsc->tbl;
< 
< 	if (fac == 0.0)		// just linear
< 	{
< 		for (i = 0; i < wsc->npts; i++)
< 			tbl[i] = i / (REAL) wsc->nend;
< 	}
< 	else
< 	{				// exponential
< 		REAL del = fac / wsc->nend, scl = (REAL) (1.0 - exp (fac));
< 		for (i = 0; i < wsc->npts; i++)
< 			tbl[i] = (REAL) ((1.0 - exp (i * del)) / scl);
< 	}
< 	wsc->fac = fac;
< }
< 
< // fac < 0: compression
< // fac > 0: expansion
< 
< WSCompander
< newWSCompander (int npts, REAL fac, CXB buff)
< {
< 	WSCompander wsc;
< 
< 	wsc = (WSCompander) safealloc (1,
< 		sizeof (WSCompanderInfo),
< 		"WSCompander struct");
< 	wsc->npts = npts;
< 	wsc->nend = npts - 1;
< 	wsc->tbl = newvec_REAL (npts, "WSCompander table");
< 	wsc->buff = newCXB (CXBsize (buff), CXBbase (buff), "WSCompander buff");
< 	WSCReset (wsc, fac);
< 	return wsc;
< }
< 
< void
< delWSCompander (WSCompander wsc)
< {
< 	if (wsc)
< 	{
< 		delvec_REAL (wsc->tbl);
< 		delCXB (wsc->buff);
< 		safefree ((char *) wsc);
< 	}
< }
---
> 
> 		if (i < end)
> 			y = tbl[i] + d * (tbl[i + 1] - tbl[i]);
> 		else
> 			y = tbl[end];
> 		return y / x;
> 	}
> 	else
> 	{
> 		return 0.0;
> 	}
> }
> 
> void
> WSCompand (WSCompander wsc)
> {
> 	int i, n = CXBsize (wsc->buff);
> 
> 	if (wsc->fac != 0.0) 
> 	{
> 		for (i = 0; i < n ; i++)
> 		{
> 			COMPLEX val = CXBdata (wsc->buff, i);
> 			REAL mag = Cmag (val), scl = WSCLookup (wsc, mag);
> 			CXBdata (wsc->buff, i) = Cscl (val,scl);
> 		}
> 	}
> }
> 
> void
> WSCReset (WSCompander wsc, REAL fac)
> {
> 	int i;
> 	REAL *tbl = wsc->tbl;
> 
> 	if (fac == 0.0)		// just linear
> 	{
> 		for (i = 0; i < wsc->npts; i++)
> 			tbl[i] = i / (REAL) wsc->nend;
> 	}
> 	else
> 	{				// exponential
> 		REAL del = fac / wsc->nend, scl = (REAL) (1.0 - exp (fac));
> 		for (i = 0; i < wsc->npts; i++)
> 			tbl[i] = (REAL) ((1.0 - exp (i * del)) / scl);
> 	}
> 	wsc->fac = fac;
> }
> 
> // fac < 0: compression
> // fac > 0: expansion
> 
> WSCompander
> newWSCompander (int npts, REAL fac, CXB buff)
> {
> 	WSCompander wsc;
> 
> 	wsc = (WSCompander) safealloc (1,
> 		sizeof (WSCompanderInfo),
> 		"WSCompander struct");
> 	wsc->npts = npts;
> 	wsc->nend = npts - 1;
> 	wsc->tbl = newvec_REAL (npts, "WSCompander table");
> 	wsc->buff = newCXB (CXBsize (buff), CXBbase (buff), "WSCompander buff");
> 	WSCReset (wsc, fac);
> 	return wsc;
> }
> 
> void
> delWSCompander (WSCompander wsc)
> {
> 	if (wsc)
> 	{
> 		delvec_REAL (wsc->tbl);
> 		delCXB (wsc->buff);
> 		safefree ((char *) wsc);
> 	}
> }
